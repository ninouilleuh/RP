<!DOCTYPE html>
<html lang="fr">
<head>
<script src="/socket.io/socket.io.js"></script>
<meta charset="UTF-8">
<title>BLEACHâ€¯RPâ€¯â€“â€¯Fichesâ€¯Joueurs</title>
<link rel="stylesheet" href="/styles.css">
</head>
<body>

<header>
  <div class="header-left">
    <h1>BLEACH RP â€“ Fiches Joueurs</h1>
    
    <div class="rp-datetime">
      <span class="rp-date" id="rpDate">ğŸ“… Vendredi 01 Avril</span>
      <span class="rp-time" id="rpTime">ğŸ• 12:00</span>
      <button class="time-btn" onclick="openTimeControl()" title="GÃ©rer le temps">â±ï¸</button>
    </div>
    <div id="connectionStatus" class="status-disconnected">ğŸ”´ DÃ©connectÃ©</div>
    <div id="playerNotification" class="player-notification"></div>
  </div>
  <div>
    <button onclick="openNew()">+ Nouvelle fiche</button>
    <select id="rpSelect"></select>
    <button onclick="openNPC()">NPC connus</button>
  </div>
</header>
<!-- Barre latÃ©rale gauche -->
<div id="sidebar">
  <button id="bestiaireBtn" onclick="openBestiaire()">ğŸ“œâ€¯Bestiaire</button>
  <button id="mapBtn" onclick="openMap()">ğŸ—ºï¸ Map</button>



</div>

<main id="container"></main>

<!-- Section Tchat RP -->
<section id="chatSection">
  <h2 class="form-title">Salon RP</h2>
  
  <!-- Joueurs connectÃ©s -->
  <div class="connected-players-bar">
    <span>ğŸ‘¥ En ligne :</span>
    <div id="connectedPlayersList"></div>
  </div>
  
  <!-- SÃ‰LECTION DU PERSONNAGE -->
  <div class="character-select-bar">
    <label>ğŸ­ Tu joues :</label>
    <select id="myCharacterSelect" onchange="selectMyCharacter()">
      <option value="-1">-- Choisir un personnage --</option>
    </select>
    <span id="myCharacterInfo"></span>
  </div>
  
  <!-- Indicateur de tour -->
  <div class="turn-indicator">
    <div class="turn-info">
      <span class="turn-number">Tour <span id="turnNumber">1</span></span>
      <span class="current-player">
        C'est au tour de : <span class="player-name" id="currentPlayerName">â€”</span>
      </span>
    </div>
    <div class="turn-controls">
      <button onclick="skipTurn()" class="skip-btn">â­ï¸ Passer</button>
      <button onclick="resetTurns()">ğŸ”„ Reset</button>
      <button onclick="toggleTurnSystem()">âš™ï¸ <span id="turnToggleText">DÃ©sactiver</span></button>
    </div>
  </div>
  
  <!-- Ordre des joueurs -->
  <div class="turn-order" id="turnOrder"></div>
  
  <!-- ONGLETS RP / OOC -->
  <div class="chat-tabs">
    <button class="chat-tab active" onclick="switchChatTab('rp')" id="tabRP">ğŸ­ RP (In Character)</button>
    <button class="chat-tab" onclick="switchChatTab('ooc')" id="tabOOC">ğŸ’¬ OOC (Hors RP) <span id="oocBadge" class="badge-notif" style="display:none;">!</span></button>
  </div>
  
  <!-- FenÃªtre de chat RP -->
  <div id="chatWindow" class="chat-window active"></div>
  
  <!-- FenÃªtre de chat OOC -->
  <div id="oocWindow" class="chat-window" style="display:none;"></div>
  
  <!-- Indicateur IA en train d'Ã©crire -->
  <div id="aiTypingIndicator" style="display:none;">
    <span class="typing-dots">ğŸ­ Le MJ rÃ©flÃ©chit<span>.</span><span>.</span><span>.</span></span>
  </div>

  <!-- ContrÃ´les RP -->
  <div id="chatControls">
    <input id="chatMsg" placeholder="Ã‰cris ton action RP..." onkeypress="if(event.key==='Enter')sendChat('joueur')" />
    <button onclick="sendChat('joueur')" id="btnSendRP">ğŸ­ Envoyer (RP)</button>
    <button onclick="sendChat('narrateur')" title="Message de narration (MJ)">ğŸ“œ Narration</button>
    <button onclick="clearChat()">ğŸ—‘ï¸</button>
  </div>
  
  <!-- ContrÃ´les OOC (cachÃ©s par dÃ©faut) -->
  <div id="oocControls" style="display:none;">
    <input id="oocMsg" placeholder="Message hors RP..." onkeypress="if(event.key==='Enter')sendOOC()" />
    <button onclick="sendOOC()">ğŸ’¬ Envoyer</button>
    <button onclick="clearOOC()">ğŸ—‘ï¸</button>
  </div>
</section>
<!-- Modal Nouvelle Fiche -->
<div class="modal" id="newModal">
  <div class="modal-content">
    <span class="close" onclick="closeNew()">&times;</span>
    <h2 class="form-title">CrÃ©erâ€¯uneâ€¯nouvelleâ€¯fiche</h2>

    <div class="form-grid">
      <div class="block">
        <label>Nom</label>
        <input id="newName" placeholder="Nom du personnage">
      </div>

      <div class="block">
        <label>Ã‚ge</label>
        <select id="newAge"></select>
      </div>

      <div class="block" style="grid-column:1/-1;">
        <label>PassÃ©â€¯/â€¯Background</label>
        <textarea id="newPast" placeholder="Ancienne vie, originesâ€¦"></textarea>
      </div>

      <div class="block">
        <label>EspÃ¨ce(s)</label>
        <select id="newSpecies" multiple>
          <option>Humain</option>
          <option>Quincy</option>
          <option>Fullbringer</option>
          <option>Shinigami</option>
          <option>Hollow</option>
          <option>Ã‚me</option>
          <option>Hybrid</option>
        </select>
      </div>

      <div class="block">
        <label>Languesâ€¯connues</label>
        <select id="newLang" multiple>
          <option>franÃ§ais</option>
          <option>anglais</option>
          <option>japonais</option>
          <option>espagnol</option>
          <option>allemand</option>
          <option>portugais</option>
        </select>
      </div>

      <div class="block" style="grid-column:1/-1;">
        <label>CompÃ©tencesâ€¯(Skills)</label>
        <textarea id="newSkills" placeholder="Zanjutsu, KidÅ, Cero, HohÅâ€¦"></textarea>
      </div>

      <div class="block">
        <label>PersonnalitÃ©</label>
        <textarea id="newTraits" placeholder="Traits de caractÃ¨re"></textarea>
      </div>

      <div class="block">
        <label>Objectifâ€¯/â€¯Goal</label>
        <textarea id="newGoals" placeholder="Motivation principale"></textarea>
      </div>
    </div>

    <button class="confirm" onclick="saveNew()">âœ…â€¯Enregistrerâ€¯laâ€¯fiche</button>
  </div>
</div>
<!-- ===== MODALE : NPC CONNUS ===== -->
<div class="modal" id="npcModal">
  <div class="modal-content">
    <span class="close" onclick="closeNPC()">&times;</span>
    <h2 class="form-title">NPC connus</h2>
    <div id="npcList" style="padding-top:10px;"></div>
  </div>
</div>
<!-- ===== MODALE : BESTIAIRE ===== -->
<div class="modal" id="bestiaireModal">
  <div class="modal-content" style="max-width:800px;">
    <span class="close" onclick="closeBestiaire()">&times;</span>
    <h2 class="form-title">Bestiaire du monde</h2>
    <p style="color:#ccc;font-size:0.9em;margin-bottom:10px;">Liste de tous les personnages canons connus et leur position actuelle.</p>
    <div id="bestiaireList"></div>
  </div>
</div>
<!-- ===== MODALE : DÃ‰TAILS PERSONNAGE ===== -->
<div class="modal" id="detailModal">
  <div class="modal-content" style="max-width:650px;">
    <span class="close" onclick="closeDetail()">&times;</span>
    <h2 class="form-title">DÃ©tails du personnage</h2>
    <div id="detailContent"></div>
  </div>
</div>
<!-- ===== MODALE : INVENTAIRE ===== -->
<div class="modal" id="invModal">
  <div class="modal-content" style="max-width:500px;">
    <span class="close" onclick="closeInv()">&times;</span>
    <h2 class="form-title" id="invTitle">Inventaire</h2>
    
    <div id="invList" class="inv-list"></div>
    
    <div class="inv-add">
      <input id="newItem" placeholder="Nouvel objet..." />
      <input id="newItemQty" type="number" value="1" min="1" max="99" style="width:60px;" />
      <button onclick="addItem()">â• Ajouter</button>
    </div>
    
    <div class="inv-footer">
      <span id="invCount">0 objets</span>
      <button class="btn" onclick="clearInventory()">ğŸ—‘ï¸ Vider tout</button>
    </div>
  </div>
</div>
<!-- ===== MODALE : DÃ‰PLACEMENT ===== -->
<div class="modal" id="travelModal">
  <div class="modal-content" style="max-width:600px;">
    <span class="close" onclick="closeTravel()">&times;</span>
    <h2 class="form-title" id="travelTitle">ğŸš¶ DÃ©placement</h2>
    
    <div class="current-location">
      <span>Position actuelle :</span>
      <strong id="currentLocationDisplay">â€”</strong>
    </div>
    
    <div class="travel-tabs">
      <button class="tab-btn active" onclick="showRegion('monde_humain')">ğŸŒ† Monde Humain</button>
      <button class="tab-btn" onclick="showRegion('soul_society')">â›©ï¸ Soul Society</button>
      <button class="tab-btn" onclick="showRegion('hueco_mundo')">ğŸœï¸ Hueco Mundo</button>
      <button class="tab-btn" onclick="showRegion('autres')">ğŸŒ€ Autres</button>
    </div>
    
    <div id="locationsList" class="locations-grid"></div>
    
    <div class="travel-footer">
      <small>ğŸ’¡ Certains lieux peuvent nÃ©cessiter des conditions spÃ©ciales pour y accÃ©der.</small>
    </div>
  </div>
</div>

<!-- ===== MODALE : MAP ===== -->
<div class="modal" id="mapModal">
  <div class="modal-content" style="max-width:900px;">
    <span class="close" onclick="closeMap()">&times;</span>
    <h2 class="form-title">ğŸ—ºï¸ Carte du Monde</h2>
    
    <!-- SÃ©lection de rÃ©gion -->
    <div class="map-regions">
      <button class="region-btn active" onclick="selectMapRegion('monde_humain')">ğŸŒ† Monde Humain</button>
      <button class="region-btn" onclick="selectMapRegion('soul_society')">â›©ï¸ Soul Society</button>
      <button class="region-btn" onclick="selectMapRegion('hueco_mundo')">ğŸœï¸ Hueco Mundo</button>
      <button class="region-btn" onclick="selectMapRegion('autres')">ğŸŒ€ Autres</button>
    </div>
    
    <!-- Grille des lieux -->
    <div class="map-container">
      <div class="map-locations" id="mapLocations"></div>
      
      <!-- Panneau de dÃ©tails du lieu -->
      <div class="location-details" id="locationDetails">
        <div class="location-placeholder">
          <span>ğŸ‘†</span>
          <p>SÃ©lectionnez un lieu pour voir les dÃ©tails</p>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ===== MODALE : CONTRÃ”LE DU TEMPS ===== -->
<div class="modal" id="timeModal">
  <div class="modal-content" style="max-width:500px;">
    <span class="close" onclick="closeTimeControl()">&times;</span>
    <h2 class="form-title">â±ï¸ ContrÃ´le du Temps RP</h2>
    
    <div class="time-display">
      <div class="time-current">
        <span class="time-label">Date & Heure actuelles</span>
        <div class="time-value" id="timeDisplayFull">Vendredi 01 Avril - 12:00</div>
      </div>
      <div class="time-tour">
        <span class="time-label">Tour actuel</span>
        <div class="time-value" id="timeDisplayTour">Tour 1</div>
      </div>
    </div>
    
    <div class="time-info">
      <p>ğŸ“– <strong>Timeline du RP :</strong></p>
      <ul>
        <li>ğŸŸ¢ <strong>Tour 1 (01/04)</strong> - DÃ©but du RP</li>
        <li>ğŸ”´ <strong>Vendredi 12/05 Ã  19:13</strong> - Rencontre Rukia/Ichigo</li>
      </ul>
      <p id="daysUntilEvent"></p>
    </div>
    
    <div class="time-controls">
      <h4>â© Avancer le temps</h4>
      <div class="time-buttons">
        <button onclick="advanceTime(0, 15)">+15 min</button>
        <button onclick="advanceTime(0, 30)">+30 min</button>
        <button onclick="advanceTime(1, 0)">+1 heure</button>
        <button onclick="advanceTime(3, 0)">+3 heures</button>
        <button onclick="advanceTime(6, 0)">+6 heures</button>
        <button onclick="advanceTime(12, 0)">+12 heures</button>
      </div>
      <div class="time-buttons">
        <button onclick="advanceDay(1)">+1 jour</button>
        <button onclick="advanceDay(3)">+3 jours</button>
        <button onclick="advanceDay(7)">+1 semaine</button>
      </div>
    </div>
    
    <div class="time-controls">
      <h4>ğŸŒ… Aller Ã  un moment</h4>
      <div class="time-buttons">
        <button onclick="setTimeOfDay(6, 0)">ğŸŒ… Aube (6h)</button>
        <button onclick="setTimeOfDay(12, 0)">â˜€ï¸ Midi (12h)</button>
        <button onclick="setTimeOfDay(18, 0)">ğŸŒ† Soir (18h)</button>
        <button onclick="setTimeOfDay(22, 0)">ğŸŒ™ Nuit (22h)</button>
      </div>
    </div>
    
    <div class="time-controls">
      <h4>ğŸ“… DÃ©finir une date prÃ©cise</h4>
      <div class="time-set-manual">
        <input type="date" id="manualDate" />
        <input type="time" id="manualTime" />
        <button onclick="setManualDateTime()">Appliquer</button>
      </div>
    </div>
    
    <div class="time-controls">
      <h4>ğŸ”„ RÃ©initialiser</h4>
      <button onclick="resetRPTime()" class="btn-danger">Revenir au 01 Avril (Tour 1)</button>
    </div>
  </div>
</div>
<!-- ===== MODALE : DÃ‰TAILS JOUEUR ===== -->
<div class="modal" id="playerDetailModal">
  <div class="modal-content" style="max-width:650px;">
    <span class="close" onclick="closePlayerDetails()">&times;</span>
    <h2 class="form-title" id="playerDetailTitle">ğŸ“‹ DÃ©tails du personnage</h2>
    <div id="playerDetailContent"></div>
  </div>
</div>

<script>
// ===== VARIABLES GLOBALES =====
let socket;
let myPlayerName = '';
let myCharacterIndex = -1;
let currentChatTab = 'rp';
let allData = {};
let currentRP;
let turnSystem = {
  enabled: true,
  currentTurn: 0,
  roundNumber: 1,
  playedThisRound: [],
  history: []
};

// Temps RP
const RP_START_DATE = new Date(2024, 3, 1, 12, 0);
const RUKIA_EVENT_DATE = new Date(2024, 4, 12, 19, 13);
let rpTime = {
  date: new Date(RP_START_DATE),
  tour: 1
};

// Jours/Mois
const JOURS = ['Dimanche', 'Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
const MOIS = ['Janvier', 'FÃ©vrier', 'Mars', 'Avril', 'Mai', 'Juin', 'Juillet', 'AoÃ»t', 'Septembre', 'Octobre', 'Novembre', 'DÃ©cembre'];

// Variables modales
let currentInvIndex = -1;
let currentTravelIndex = -1;
let currentRegion = 'monde_humain';
let currentDetailIndex = -1;
let currentMapRegion = 'monde_humain';
let selectedLocation = null;

// ===== INITIALISATION =====
document.addEventListener('DOMContentLoaded', () => {
  initSocket();
  requestNotificationPermission();
});

// ===== SOCKET.IO CLIENT =====
function initSocket() {
  socket = io();
  
  // Demander le nom du visiteur
  myPlayerName = localStorage.getItem('visitorName');
  if (!myPlayerName) {
    myPlayerName = prompt("Entrez votre nom (vous, pas votre personnage):") || "Visiteur" + Math.floor(Math.random() * 1000);
    localStorage.setItem('visitorName', myPlayerName);
  }
  
  // RÃ©cupÃ©rer le personnage sauvegardÃ©
  const savedChar = localStorage.getItem('myCharacterIndex');
  if (savedChar !== null) {
    myCharacterIndex = parseInt(savedChar);
  }
  
  // === CONNEXION ===
  socket.on("connect", () => {
    console.log("âœ… ConnectÃ© au serveur");
    socket.emit("joinGame", {
      visitorName: myPlayerName,
      characterIndex: myCharacterIndex
    });
    updateConnectionStatus(true);
  });
  
  socket.on("disconnect", () => {
    console.log("âŒ DÃ©connectÃ©");
    updateConnectionStatus(false);
  });
  
  // === Ã‰TAT INITIAL ===
  socket.on("gameState", (state) => {
    allData = state.rpData || {};
    turnSystem = state.turnSystem || turnSystem;
    
    // Charger le RP
    const sel = document.getElementById("rpSelect");
    if (sel) {
      sel.innerHTML = "";
      Object.keys(allData).forEach(id => {
        const opt = document.createElement("option");
        opt.value = id;
        opt.textContent = allData[id].title;
        sel.appendChild(opt);
      });
      
      sel.onchange = () => {
        currentRP = allData[sel.value];
        showPlayers(currentRP);
        initTurnSystem();
        initRPTime();
      };
    }
    
    currentRP = allData[state.currentRP] || allData[Object.keys(allData)[0]];
    if (currentRP) {
      showPlayers(currentRP);
      updateCharacterSelect();
      updateTurnDisplay();
    }
    
    // Charger le chat RP
    const chatWindow = document.getElementById("chatWindow");
    if (chatWindow) {
      chatWindow.innerHTML = "";
      if (state.chat) {
        state.chat.forEach(msg => addChatMessage(msg));
      }
    }
    
    // Charger le chat OOC
    const oocWindow = document.getElementById("oocWindow");
    if (oocWindow) {
      oocWindow.innerHTML = "";
      if (state.oocChat) {
        state.oocChat.forEach(msg => addOOCMessage(msg));
      }
    }
    
    // Mettre Ã  jour les joueurs connectÃ©s
    if (state.connectedPlayers) {
      updateConnectedPlayers(state.connectedPlayers);
    }
    
    // Mettre Ã  jour le temps RP
    if (state.rpTime) {
      rpTime = { 
        date: new Date(state.rpTime.date), 
        tour: state.rpTime.tour 
      };
      updateTimeDisplay();
    }
  });
  
  // === MESSAGES RP ===
  socket.on("chatMessage", (msg) => {
    addChatMessage(msg);
  });
  
  // === MESSAGES OOC ===
  socket.on("oocMessage", (msg) => {
    addOOCMessage(msg);
    
    if (currentChatTab !== 'ooc') {
      const badge = document.getElementById('oocBadge');
      if (badge) badge.style.display = 'inline';
    }
  });
  
  // === IA EN TRAIN D'Ã‰CRIRE ===
  socket.on("aiTyping", (isTyping) => {
    const indicator = document.getElementById("aiTypingIndicator");
    if (indicator) {
      indicator.style.display = isTyping ? "block" : "none";
    }
  });
  
  // === TOUR CHANGÃ‰ ===
  socket.on("turnChanged", (data) => {
    turnSystem = data.turnSystem;
    updateTurnDisplay();
    updateMyCharacterInfo();
    
    if (myCharacterIndex >= 0 && turnSystem.currentTurn === myCharacterIndex) {
      showNotification("ğŸ® C'est ton tour !");
      const myInfo = document.getElementById('myCharacterInfo');
      if (myInfo) myInfo.classList.add('my-turn');
    }
  });
  
  // === JOUEUR MIS Ã€ JOUR ===
  socket.on("playerUpdated", (data) => {
    if (currentRP?.players?.[data.playerIndex]) {
      currentRP.players[data.playerIndex] = data.player;
      showPlayers(currentRP);
      updateCharacterSelect();
    }
  });

  // === JOUEUR AJOUTÃ‰ ===
  socket.on("playerAdded", (data) => {
    if (currentRP?.players) {
      // Player already added by server, just refresh display
      showPlayers(currentRP);
      updateCharacterSelect();
    }
  });
  
  // === DONNÃ‰ES MISES Ã€ JOUR ===
  socket.on("dataUpdated", (newData) => {
    allData = newData;
    currentRP = allData[Object.keys(allData)[0]];
    showPlayers(currentRP);
    updateCharacterSelect();
  });
  
  // === JOUEURS CONNECTÃ‰S ===
  socket.on("playersUpdated", (players) => {
    updateConnectedPlayers(players);
  });

  // === JOUEUR REJOINT (transient notification) ===
  socket.on("playerJoined", (data) => {
    showPlayerNotification(`ğŸŸ¢ ${data.visitorName} a rejoint la partie`, 'join');
  });

  // === JOUEUR PARTI (transient notification) ===
  socket.on("playerLeft", (data) => {
    showPlayerNotification(`ğŸ”´ ${data.visitorName} a quittÃ© la partie`, 'leave');
  });
  
  // === CHAT VIDÃ‰ ===
  socket.on("chatCleared", () => {
    const chatWindow = document.getElementById("chatWindow");
    if (chatWindow) chatWindow.innerHTML = "";
  });
  
  // === OOC VIDÃ‰ ===
  socket.on("oocCleared", () => {
    const oocWindow = document.getElementById("oocWindow");
    if (oocWindow) oocWindow.innerHTML = "";
  });
  
  // === TEMPS RP MIS Ã€ JOUR ===
  socket.on("rpTimeUpdated", (newTime) => {
    rpTime = { date: new Date(newTime.date), tour: newTime.tour };
    updateTimeDisplay();
  });
}

// ===== UTILITAIRES =====

function formatTime(timestamp) {
  if (!timestamp) return '';
  
  try {
    const d = new Date(timestamp);
    if (isNaN(d.getTime())) {
      console.warn('Invalid timestamp:', timestamp);
      return '';
    }
    
    const hours = d.getHours().toString().padStart(2, '0');
    const minutes = d.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  } catch (e) {
    console.error('Error formatting time:', e);
    return '';
  }
}

function escapeHtml(text) {
  if (!text) return '';
  if (typeof text !== 'string') return String(text);
  
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function showNotification(text) {
  // Browser notification
  if ("Notification" in window && Notification.permission === "granted") {
    try {
      new Notification("Bleach RP", { body: text, icon: 'ğŸ­' });
    } catch (e) {
      console.log('Notification error:', e);
    }
  }
  
  // Visual notification
  const banner = document.createElement('div');
  banner.className = 'notification-banner';
  banner.innerHTML = `<span>${escapeHtml(text)}</span>`;
  banner.style.cssText = `
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 9999;
    background: linear-gradient(135deg, #1a3a1a, #2a5a2a);
    border: 2px solid #4caf50;
    color: #4caf50;
    padding: 15px 30px;
    border-radius: 10px;
    font-weight: bold;
    font-size: 1.1em;
    box-shadow: 0 5px 20px rgba(0,0,0,0.5);
    animation: fadeInOut 3s forwards;
  `;
  document.body.appendChild(banner);
  
  setTimeout(() => {
    if (banner.parentNode) {
      banner.remove();
    }
  }, 3000);
}

function updateConnectionStatus(connected) {
  const status = document.getElementById("connectionStatus");
  if (status) {
    status.innerHTML = connected 
      ? `ğŸŸ¢ ${myPlayerName}`
      : 'ğŸ”´ DÃ©connectÃ©';
    status.className = connected ? 'status-connected' : 'status-disconnected';
  }
}

function showPlayerNotification(message, type) {
  const notifDiv = document.getElementById("playerNotification");
  if (!notifDiv) return;
  
  notifDiv.textContent = message;
  notifDiv.className = `player-notification player-notification-${type}`;
  notifDiv.style.display = 'block';
  
  // Auto-hide after 4 seconds
  setTimeout(() => {
    notifDiv.style.display = 'none';
  }, 4000);
}

function updateConnectedPlayers(players) {
  const list = document.getElementById("connectedPlayersList");
  if (!list) return;
  
  if (!players || !Array.isArray(players)) {
    list.innerHTML = '<span class="connected-player">Aucun joueur</span>';
    return;
  }
  
  list.innerHTML = players.map(p => {
    const isMe = p.visitorName === myPlayerName;
    const character = (p.characterIndex >= 0 && currentRP?.players?.[p.characterIndex]) 
      ? currentRP.players[p.characterIndex] 
      : null;
    const charName = character ? character.name : null;
    
    let display = p.visitorName || 'Anonyme';
    if (charName) {
      display += ` â†’ ${charName}`;
    }
    
    return `
      <span class="connected-player ${isMe ? 'me' : ''}" title="${charName ? 'Joue: ' + charName : 'Pas de personnage sÃ©lectionnÃ©'}">
        ${escapeHtml(display)}
      </span>
    `;
  }).join('');
}

function requestNotificationPermission() {
  if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission().then(permission => {
      console.log('Notification permission:', permission);
    });
  }
}

// ===== SÃ‰LECTION DE PERSONNAGE =====

function updateCharacterSelect() {
  const select = document.getElementById('myCharacterSelect');
  if (!select || !currentRP?.players) return;
  
  const previousValue = select.value;
  
  select.innerHTML = '<option value="-1">-- Choisir un personnage --</option>';
  
  currentRP.players.forEach((p, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = `${p.name} (${p.species || 'Inconnu'}) - Niv.${p.level || 1}`;
    
    if (turnSystem.enabled && turnSystem.currentTurn === i) {
      opt.textContent += ' â­ (son tour)';
    }
    
    select.appendChild(opt);
  });
  
  if (myCharacterIndex >= 0 && myCharacterIndex < currentRP.players.length) {
    select.value = myCharacterIndex;
  } else if (previousValue !== '-1' && parseInt(previousValue) < currentRP.players.length) {
    select.value = previousValue;
    myCharacterIndex = parseInt(previousValue);
  }
  
  updateMyCharacterInfo();
}

// ===== SUITE DU CODE CORRIGÃ‰ =====

function selectMyCharacter() {
  const select = document.getElementById('myCharacterSelect');
  myCharacterIndex = parseInt(select.value);
  
  localStorage.setItem('myCharacterIndex', myCharacterIndex);
  
  if (socket) {
    socket.emit("selectCharacter", myCharacterIndex);
  }
  
  updateMyCharacterInfo();
  updateTurnDisplay();
  
  if (myCharacterIndex >= 0 && currentRP?.players?.[myCharacterIndex]) {
    const pj = currentRP.players[myCharacterIndex];
    appendSystemMsg(`ğŸ­ Tu incarnes maintenant ${pj.name}`);
  }
}

function updateMyCharacterInfo() {
  const info = document.getElementById('myCharacterInfo');
  const sendBtn = document.getElementById('btnSendRP');
  const chatInput = document.getElementById('chatMsg');
  const controls = document.getElementById('chatControls');
  
  if (!info) return;
  
  if (myCharacterIndex < 0 || !currentRP?.players?.[myCharacterIndex]) {
    info.innerHTML = '<span style="color:#f44336;">âš ï¸ SÃ©lectionne un personnage</span>';
    info.classList.remove('my-turn');
    
    if (chatInput) chatInput.placeholder = "SÃ©lectionne d'abord un personnage...";
    if (sendBtn) sendBtn.disabled = true;
    if (controls) controls.classList.remove('not-your-turn');
    return;
  }
  
  const pj = currentRP.players[myCharacterIndex];
  const isMyTurn = turnSystem.enabled && turnSystem.currentTurn === myCharacterIndex;
  
  if (sendBtn) sendBtn.disabled = false;
  
  if (isMyTurn) {
    info.innerHTML = `âœ¨ <strong style="color:#4caf50;">C'EST TON TOUR !</strong> | â¤ï¸ ${pj.hp}/${pj.maxHp} | ğŸ“ ${pj.location || 'Inconnu'}`;
    info.classList.add('my-turn');
    
    if (chatInput) chatInput.placeholder = `C'est ton tour ! Que fait ${pj.name} ?`;
    if (controls) controls.classList.remove('not-your-turn');
  } else if (turnSystem.enabled) {
    const currentPlayer = currentRP.players[turnSystem.currentTurn];
    info.innerHTML = `â³ Tour de ${currentPlayer?.name || '?'} | â¤ï¸ ${pj.hp}/${pj.maxHp} | ğŸ“ ${pj.location || 'Inconnu'}`;
    info.classList.remove('my-turn');
    
    if (chatInput) chatInput.placeholder = `En attente... (tour de ${currentPlayer?.name || '?'})`;
    if (controls) controls.classList.add('not-your-turn');
  } else {
    info.innerHTML = `ğŸ†“ Mode libre | â¤ï¸ ${pj.hp}/${pj.maxHp} | ğŸ“ ${pj.location || 'Inconnu'}`;
    info.classList.remove('my-turn');
    
    if (chatInput) chatInput.placeholder = `Que fait ${pj.name} ?`;
    if (controls) controls.classList.remove('not-your-turn');
  }
}

// ===== SYSTÃˆME DE CHAT =====

function switchChatTab(tab) {
  currentChatTab = tab;
  
  const tabRP = document.getElementById('tabRP');
  const tabOOC = document.getElementById('tabOOC');
  const chatWindow = document.getElementById('chatWindow');
  const oocWindow = document.getElementById('oocWindow');
  const chatControls = document.getElementById('chatControls');
  const oocControls = document.getElementById('oocControls');
  const oocBadge = document.getElementById('oocBadge');
  
  if (tabRP) tabRP.classList.toggle('active', tab === 'rp');
  if (tabOOC) tabOOC.classList.toggle('active', tab === 'ooc');
  if (chatWindow) chatWindow.style.display = tab === 'rp' ? 'block' : 'none';
  if (oocWindow) oocWindow.style.display = tab === 'ooc' ? 'block' : 'none';
  if (chatControls) chatControls.style.display = tab === 'rp' ? 'flex' : 'none';
  if (oocControls) oocControls.style.display = tab === 'ooc' ? 'flex' : 'none';
  
  if (tab === 'ooc' && oocBadge) {
    oocBadge.style.display = 'none';
  }
  
  const activeWindow = tab === 'rp' ? chatWindow : oocWindow;
  if (activeWindow) activeWindow.scrollTop = activeWindow.scrollHeight;
}

function sendChat(type) {
  const msgField = document.getElementById("chatMsg");
  const txt = msgField.value.trim();
  if (!txt) return;
  
  if (type === 'joueur') {
    if (myCharacterIndex < 0 || !currentRP?.players?.[myCharacterIndex]) {
      alert("âš ï¸ SÃ©lectionne d'abord un personnage pour envoyer un message RP !");
      return;
    }
    
    if (turnSystem.enabled && turnSystem.currentTurn !== myCharacterIndex) {
      const currentPlayer = currentRP.players[turnSystem.currentTurn];
      if (!confirm(`âš ï¸ Ce n'est pas ton tour ! C'est au tour de ${currentPlayer?.name}.\n\nEnvoyer quand mÃªme ?`)) {
        return;
      }
    }
  }
  
  msgField.value = "";
  
  const character = myCharacterIndex >= 0 ? currentRP.players[myCharacterIndex] : null;
  const characterName = character ? character.name : myPlayerName;
  
  if (socket) {
    socket.emit("sendMessage", {
      type: type,
      text: txt,
      characterName: characterName,
      characterIndex: myCharacterIndex
    });
    
    if (type === 'joueur' && turnSystem.enabled && turnSystem.currentTurn === myCharacterIndex) {
      socket.emit("nextTurn");
    }
  }
}

function sendOOC() {
  const msgField = document.getElementById("oocMsg");
  const txt = msgField.value.trim();
  if (!txt) return;
  
  msgField.value = "";
  
  if (socket) {
    socket.emit("sendOOC", {
      text: txt,
      author: myPlayerName
    });
  }
}

function addChatMessage(msg) {
  const win = document.getElementById("chatWindow");
  if (!win) return;
  
  const div = document.createElement("div");
  const isMyMessage = msg.characterIndex === myCharacterIndex && myCharacterIndex >= 0;
  
  if (msg.type === 'system') {
    div.className = "msg system";
    div.innerHTML = msg.text;
  } else if (msg.type === 'joueur') {
    div.className = `msg joueur${isMyMessage ? ' mine' : ''}`;
    div.innerHTML = `
      <div class="msg-header">
        <span class="msg-author">ğŸ­ ${msg.author || 'Inconnu'}</span>
        <span class="msg-meta">Tour ${msg.turn || '?'} â€¢ ${formatTime(msg.timestamp)}</span>
      </div>
      <div class="msg-content">${escapeHtml(msg.text)}</div>
    `;
  } else if (msg.type === 'narrateur') {
    div.className = "msg narrateur";
    div.innerHTML = `
      <div class="msg-header">
        <span class="msg-author">ğŸ“œ ${msg.author || 'Narrateur'}</span>
        <span class="msg-meta">Tour ${msg.turn || '?'}</span>
      </div>
      <div class="msg-content">${escapeHtml(msg.text)}</div>
    `;
  } else {
    div.className = "msg";
    div.innerHTML = msg.text;
  }
  
  win.appendChild(div);
  win.scrollTop = win.scrollHeight;
}

function addOOCMessage(msg) {
  const win = document.getElementById("oocWindow");
  if (!win) return;
  
  const div = document.createElement("div");
  div.className = "msg ooc";
  
  const isMyMessage = msg.author === myPlayerName;
  
  div.innerHTML = `
    <div class="msg-header">
      <span class="msg-author">${isMyMessage ? 'ğŸ‘¤ Toi' : msg.author || 'Anonyme'}</span>
      <span class="msg-meta">${formatTime(msg.timestamp)}</span>
    </div>
    <div class="msg-content">${escapeHtml(msg.text)}</div>
  `;
  
  if (isMyMessage) {
    div.style.marginLeft = 'auto';
    div.style.background = 'linear-gradient(135deg, #2a3020, #303525)';
  }
  
  win.appendChild(div);
  win.scrollTop = win.scrollHeight;
}

function appendSystemMsg(text) {
  const win = document.getElementById("chatWindow");
  if (!win) return;
  
  const div = document.createElement("div");
  div.className = "msg system";
  div.innerHTML = text;
  win.appendChild(div);
  win.scrollTop = win.scrollHeight;
}

function appendMsg(role, text) {
  if (role === 'system') {
    appendSystemMsg(text);
  } else {
    addChatMessage({
      type: role,
      text: text,
      author: role === 'narrateur' ? 'ğŸ“œ MJ' : 'SystÃ¨me',
      turn: turnSystem?.roundNumber || 1,
      timestamp: new Date().toISOString()
    });
  }
}

function clearChat() {
  if (confirm("Vider le salon RP ?")) {
    if (socket) socket.emit("clearChat");
  }
}

function clearOOC() {
  if (confirm("Vider le chat OOC ?")) {
    if (socket) socket.emit("clearOOC");
  }
}

// ===== SYSTÃˆME DE TOURS =====

function initTurnSystem() {
  if (!currentRP || !currentRP.players || currentRP.players.length === 0) {
    const turnIndicator = document.querySelector('.turn-indicator');
    const turnOrder = document.querySelector('.turn-order');
    if (turnIndicator) turnIndicator.style.display = 'none';
    if (turnOrder) turnOrder.style.display = 'none';
    return;
  }
  
  const turnIndicator = document.querySelector('.turn-indicator');
  const turnOrder = document.querySelector('.turn-order');
  if (turnIndicator) turnIndicator.style.display = 'flex';
  if (turnOrder) turnOrder.style.display = 'flex';
  
  turnSystem.currentTurn = 0;
  turnSystem.roundNumber = 1;
  turnSystem.playedThisRound = [];
  
  updateTurnDisplay();
}

function updateTurnDisplay() {
  const turnIndicator = document.querySelector('.turn-indicator');
  const turnOrderEl = document.querySelector('.turn-order');
  
  if (!currentRP?.players || currentRP.players.length === 0) {
    if (turnIndicator) turnIndicator.style.display = 'none';
    if (turnOrderEl) turnOrderEl.style.display = 'none';
    return;
  }
  
  if (turnIndicator) turnIndicator.style.display = 'flex';
  if (turnOrderEl) turnOrderEl.style.display = 'flex';
  
  const players = currentRP.players;
  const currentPlayer = players[turnSystem.currentTurn];
  
  const turnNumber = document.getElementById('turnNumber');
  const currentPlayerName = document.getElementById('currentPlayerName');
  const turnToggleText = document.getElementById('turnToggleText');
  const orderDiv = document.getElementById('turnOrder');
  
  if (turnNumber) turnNumber.innerText = turnSystem.roundNumber;
  if (currentPlayerName) currentPlayerName.innerText = currentPlayer?.name || 'â€”';
  if (turnToggleText) turnToggleText.innerText = turnSystem.enabled ? 'DÃ©sactiver' : 'Activer';
  
  if (orderDiv) {
    orderDiv.innerHTML = players.map((p, i) => {
      let classes = 'turn-player';
      if (i === turnSystem.currentTurn && turnSystem.enabled) classes += ' active';
      if (turnSystem.playedThisRound.includes(i)) classes += ' played';
      if (i === myCharacterIndex) classes += ' mine';
      
      return `
        <div class="${classes}" onclick="jumpToPlayer(${i})" title="Cliquer pour passer Ã  ce joueur (MJ)">
          <span class="player-index">${i + 1}</span>
          ${p.name}
          ${i === myCharacterIndex ? ' (toi)' : ''}
        </div>
      `;
    }).join('');
  }
  
  updateMyCharacterInfo();
  updateCharacterSelect();
}

function jumpToPlayer(index) {
  if (!turnSystem.enabled) return;
  
  const player = currentRP.players[index];
  if (confirm(`Passer directement au tour de ${player.name} ?`)) {
    turnSystem.currentTurn = index;
    if (socket) socket.emit("setTurn", index);
    appendSystemMsg(`ğŸ¯ C'est maintenant au tour de ${player.name}.`);
    updateTurnDisplay();
  }
}

function skipTurn() {
  if (socket) socket.emit("skipTurn");
}

function resetTurns() {
  if (confirm("RÃ©initialiser les tours ?")) {
    if (socket) socket.emit("resetTurns");
  }
}

function toggleTurnSystem() {
  if (socket) socket.emit("toggleTurnSystem");
}

function nextTurn() {
  if (!currentRP || !currentRP.players || currentRP.players.length === 0) return;
  
  const players = currentRP.players;
  
  if (!turnSystem.playedThisRound.includes(turnSystem.currentTurn)) {
    turnSystem.playedThisRound.push(turnSystem.currentTurn);
  }
  
  turnSystem.currentTurn = (turnSystem.currentTurn + 1) % players.length;
  
  if (turnSystem.currentTurn === 0) {
    turnSystem.roundNumber++;
    turnSystem.playedThisRound = [];
    advanceTimeOnTurn(5);
    rpTime.tour = turnSystem.roundNumber;
    appendMsg('system', `â•â•â•â•â•â•â•â•â•â•â• ğŸ”„ TOUR ${turnSystem.roundNumber} â•â•â•â•â•â•â•â•â•â•â•`);
    checkSpecialEvents();
  }
  
  updateTurnDisplay();
  updateTimeDisplay();
}

// ===== AFFICHAGE DES JOUEURS =====

// ===== SUITE DU CODE CORRIGÃ‰ (PARTIE 3) =====

function showPlayers(rp) {
  if (!rp) return;
  
  currentRP = rp;
  const cont = document.getElementById("container");
  if (!cont) return;
  
  cont.innerHTML = "";
  
  if (!rp.players) rp.players = [];
  
  rp.players.forEach((p, i) => {
    // Initialiser les valeurs manquantes
    if (p.hp === undefined) p.hp = 100;
    if (p.maxHp === undefined) p.maxHp = 100;
    if (p.reiatsu === undefined) p.reiatsu = 50;
    if (p.maxReiatsu === undefined) p.maxReiatsu = 50;
    if (p.stamina === undefined) p.stamina = 50;
    if (p.maxStamina === undefined) p.maxStamina = 50;
    if (!p.status) p.status = [];
    
    const hpPercent = Math.max(0, Math.min(100, (p.hp / p.maxHp) * 100));
    const reiatsuPercent = Math.max(0, Math.min(100, (p.reiatsu / p.maxReiatsu) * 100));
    const staminaPercent = Math.max(0, Math.min(100, (p.stamina / p.maxStamina) * 100));
    
    const statusHTML = p.status.length > 0 
      ? `<div class="status-tags">${p.status.map(s => `<span class="status-tag ${getStatusClass(s)}">${getStatusIcon(s)} ${s}</span>`).join('')}</div>`
      : '';
    
    const c = document.createElement("div");
    c.className = "card";
    if (p.hp <= 0) c.classList.add('card-ko');
    
    c.innerHTML = `
      <div class="card-header">
        <div class="name">${p.name}</div>
        <div class="level-badge">Niv. ${p.level || 1}</div>
      </div>
      <div class="species">${p.species}</div>
      
      <div class="resource-bars">
        <div class="resource-bar-container">
          <div class="resource-label">
            <span>${p.hp <= 0 ? 'ğŸ’€' : 'â¤ï¸'} HP</span>
            <span>${p.hp}/${p.maxHp}</span>
          </div>
          <div class="resource-bar hp-bar-bg">
            <div class="resource-fill hp-fill-color" style="width:${hpPercent}%"></div>
          </div>
        </div>
        
        <div class="resource-bar-container">
          <div class="resource-label">
            <span>ğŸ”µ Reiatsu</span>
            <span>${p.reiatsu}/${p.maxReiatsu}</span>
          </div>
          <div class="resource-bar reiatsu-bar-bg">
            <div class="resource-fill reiatsu-fill-color" style="width:${reiatsuPercent}%"></div>
          </div>
        </div>
        
        <div class="resource-bar-container">
          <div class="resource-label">
            <span>ğŸŸ¡ Stamina</span>
            <span>${p.stamina}/${p.maxStamina}</span>
          </div>
          <div class="resource-bar stamina-bar-bg">
            <div class="resource-fill stamina-fill-color" style="width:${staminaPercent}%"></div>
          </div>
        </div>
      </div>
      
      ${statusHTML}
      
      <div class="location-info">
        <span class="location-icon">ğŸ“</span>
        <span class="location-name">${p.location || "Inconnu"}</span>
      </div>
      
      <div class="xp-bar">
        <div class="xp-fill" style="width:${(p.xp || 0) % 100}%"></div>
        <span class="xp-text">XP: ${p.xp || 0}/100</span>
      </div>
      
      <div class="card-buttons">
        <button class='btn btn-details' onclick='openPlayerDetails(${i})'>ğŸ“‹ DÃ©tails</button>
        <button class='btn' onclick='openInventory(${i})'>ğŸ’</button>
        <button class='btn' onclick='openTravel(${i})'>ğŸš¶</button>
        <button class='btn' onclick='addXP(${i})'>â­</button>
        <button class='btn btn-danger-small' onclick='deleteCard(${i})'>ğŸ—‘ï¸</button>
      </div>
    `;
    cont.appendChild(c);
  });
  
  if (typeof updateTurnDisplay === 'function') {
    updateTurnDisplay();
  }
}

// ===== FONCTIONS UTILITAIRES POUR LES STATS =====

function getHpColor(percent) {
  if (percent > 70) return 'linear-gradient(90deg, #4caf50, #8bc34a)';
  if (percent > 40) return 'linear-gradient(90deg, #ff9800, #ffc107)';
  if (percent > 15) return 'linear-gradient(90deg, #f44336, #ff5722)';
  return 'linear-gradient(90deg, #9c27b0, #673ab7)';
}

function getStatusClass(status) {
  const s = status.toLowerCase();
  if (['empoisonnÃ©', 'poison', 'brÃ»lÃ©', 'saignement'].includes(s)) return 'status-bad';
  if (['soignÃ©', 'bouclier', 'buff', 'renforcÃ©'].includes(s)) return 'status-good';
  if (['ko', 'mort', 'inconscient'].includes(s)) return 'status-critical';
  return 'status-neutral';
}

function getStatusIcon(status) {
  const icons = {
    'empoisonnÃ©': 'ğŸ¤¢',
    'poison': 'ğŸ¤¢',
    'brÃ»lÃ©': 'ğŸ”¥',
    'saignement': 'ğŸ©¸',
    'soignÃ©': 'ğŸ’š',
    'bouclier': 'ğŸ›¡ï¸',
    'buff': 'â¬†ï¸',
    'renforcÃ©': 'ğŸ’ª',
    'ko': 'ğŸ’€',
    'mort': 'â˜ ï¸',
    'inconscient': 'ğŸ˜µ',
    'fatiguÃ©': 'ğŸ˜´',
    'paralysÃ©': 'âš¡',
    'gelÃ©': 'â„ï¸',
    'confus': 'ğŸ˜µâ€ğŸ’«'
  };
  return icons[status.toLowerCase()] || 'â“';
}

function getStatColor(percent) {
  if (percent >= 90) return 'linear-gradient(90deg, #ffd700, #ffaa00)';
  if (percent >= 70) return 'linear-gradient(90deg, #4caf50, #8bc34a)';
  if (percent >= 50) return 'linear-gradient(90deg, #2196f3, #00bcd4)';
  if (percent >= 30) return 'linear-gradient(90deg, #ff9800, #ffc107)';
  return 'linear-gradient(90deg, #f44336, #ff5722)';
}

// ===== SYNCHRONISATION AVEC LE SERVEUR =====

function syncPlayerUpdate(playerIndex) {
  const player = currentRP.players[playerIndex];
  if (socket) {
    socket.emit("updatePlayer", {
      playerIndex: playerIndex,
      updates: player
    });
  }
}

function changeHP(index, amount) {
  const pj = currentRP.players[index];
  const oldHp = pj.hp;
  
  pj.hp = Math.max(0, Math.min(pj.maxHp, pj.hp + amount));
  
  if (pj.hp <= 0 && oldHp > 0) {
    if (!pj.status.includes('KO')) pj.status.push('KO');
  } else if (pj.hp > 0 && pj.status.includes('KO')) {
    pj.status = pj.status.filter(s => s !== 'KO');
  }
  
  showPlayers(currentRP);
  syncPlayerUpdate(index);
}

// ===== GESTION DES RESSOURCES =====

function modifyResource(resource, amount) {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  const maxKey = 'max' + resource.charAt(0).toUpperCase() + resource.slice(1);
  const maxValue = pj[maxKey] || 100;
  
  if (amount === 999) {
    pj[resource] = maxValue;
  } else {
    pj[resource] = Math.max(0, Math.min(maxValue, (pj[resource] || 0) + amount));
  }
  
  if (resource === 'hp') {
    if (pj.hp <= 0 && !pj.status.includes('KO')) {
      pj.status.push('KO');
    } else if (pj.hp > 0) {
      pj.status = pj.status.filter(s => s !== 'KO');
    }
  }
  
  openPlayerDetails(currentDetailIndex);
  showPlayers(currentRP);
  syncPlayerUpdate(currentDetailIndex);
}

// ===== XP ET LEVEL UP =====

function addXP(i) {
  const pj = currentRP.players[i];
  pj.xp = (pj.xp || 0) + 10;
  
  if (pj.xp >= 100) {
    pj.level = (pj.level || 1) + 1;
    pj.xp = pj.xp - 100;
    
    if (!pj.stats) {
      pj.stats = { Reiatsu: 5, Endurance: 5, Hakuda: 5, Defense: 5, Hoho: 5, Intellect: 5 };
    }
    
    const statKeys = Object.keys(pj.stats);
    const randomKey = statKeys[Math.floor(Math.random() * statKeys.length)];
    const bonus = Math.floor(Math.random() * 3) + 1;
    pj.stats[randomKey] = Math.min(100, pj.stats[randomKey] + bonus);
    
    alert(`ğŸ‰ ${pj.name} passe niveau ${pj.level} !\n+${bonus} en ${randomKey}`);
  }
  
  showPlayers(currentRP);
  syncPlayerUpdate(i);
}

// ===== CRÃ‰ATION DE PERSONNAGE =====

function openNew() {
  const modal = document.getElementById("newModal");
  if (modal) {
    genAgeOptions(100);
    modal.style.display = "flex";
    
    const speciesSelect = document.getElementById("newSpecies");
    if (speciesSelect) {
      speciesSelect.onchange = updateAgeChoices;
    }
  }
}

function closeNew() {
  const modal = document.getElementById("newModal");
  if (modal) modal.style.display = "none";
}

function genAgeOptions(max, step = 1) {
  const sel = document.getElementById("newAge");
  if (!sel) return;
  
  sel.innerHTML = "";
  if (max > 1000) {
    sel.innerHTML = "<option>50</option><option>100</option><option>500</option><option>1000</option><option>5000</option><option>10000+</option>";
    return;
  }
  for (let i = 1; i <= max; i += step) {
    const o = document.createElement("option");
    o.text = i;
    o.value = i;
    sel.appendChild(o);
  }
}

function updateAgeChoices() {
  const speciesSelect = document.getElementById("newSpecies");
  if (!speciesSelect) return;
  
  const vals = Array.from(speciesSelect.selectedOptions).map(o => o.text);
  if (vals.some(v => ["Shinigami", "Hollow", "Ã‚me"].includes(v))) {
    genAgeOptions(10000);
  } else {
    genAgeOptions(100);
  }
}

function saveNew() {
  const speciesSelect = document.getElementById("newSpecies");
  const species = speciesSelect ? Array.from(speciesSelect.selectedOptions).map(o => o.text) : ['Humain'];
  
  const stats = generateStatsForRace(species);
  
  const nameInput = document.getElementById("newName");
  const ageInput = document.getElementById("newAge");
  const pastInput = document.getElementById("newPast");
  const skillsInput = document.getElementById("newSkills");
  const langInput = document.getElementById("newLang");
  const traitsInput = document.getElementById("newTraits");
  const goalsInput = document.getElementById("newGoals");
  
  const n = {
    name: nameInput ? nameInput.value.trim() : '',
    age: ageInput ? ageInput.value : '20',
    past: pastInput ? pastInput.value.trim() : '',
    species: species.join(", "),
    skills: skillsInput ? skillsInput.value.trim() : '',
    languages: langInput ? Array.from(langInput.selectedOptions).map(o => o.text).join(", ") : '',
    traits: traitsInput ? traitsInput.value.trim() : '',
    goals: goalsInput ? goalsInput.value.trim() : '',
    inventory: [],
    level: 1,
    xp: 0,
    location: "Karakura Town",
    hp: stats.maxHp,
    maxHp: stats.maxHp,
    reiatsu: stats.maxReiatsu,
    maxReiatsu: stats.maxReiatsu,
    stamina: stats.maxStamina,
    maxStamina: stats.maxStamina,
    status: [],
    stats: stats.attributes,
    raceBonuses: stats.bonuses
  };
  
  if (!n.name) {
    alert("Nom obligatoire");
    return;
  }
  
  // Emit to server via socket to add player and save to DB
  socket.emit('addPlayer', n);
  
  // Immediately add to local state and refresh UI
  if (!currentRP.players) currentRP.players = [];
  currentRP.players.push(n);
  
  closeNew();
  showPlayers(currentRP);
  updateCharacterSelect();
  
  appendMsg('system', `âœ¨ ${n.name} crÃ©Ã©(e) ! Race: ${n.species}`);
  appendMsg('system', `ğŸ“Š Stats: Reiatsu ${n.stats.Reiatsu}, Endurance ${n.stats.Endurance}, Hakuda ${n.stats.Hakuda}, DÃ©fense ${n.stats.Defense}, HohÅ ${n.stats.Hoho}, Intellect ${n.stats.Intellect}`);
}

// ===== GÃ‰NÃ‰RATION DE STATS PAR RACE =====

// ===== SUITE DU CODE CORRIGÃ‰ (PARTIE 4) =====

function generateStatsForRace(speciesArray) {
  let baseStats = {
    Reiatsu: 0,
    Endurance: 0,
    Hakuda: 0,
    Defense: 0,
    Hoho: 0,
    Intellect: 0
  };
  
  let bonuses = [];
  let hpBase = 50;
  let reiatsuBase = 30;
  let staminaBase = 30;
  
  const raceConfigs = {
    'Humain': {
      ranges: { Reiatsu: [0, 5], Endurance: [2, 7], Hakuda: [1, 6], Defense: [1, 5], Hoho: [1, 5], Intellect: [2, 8] },
      hpBonus: 0, reiatsuBonus: 0, staminaBonus: 10,
      bonusDesc: 'ğŸ§‘ Humain: +10 Stamina, Intellect Ã©levÃ©'
    },
    'Shinigami': {
      ranges: { Reiatsu: [3, 8], Endurance: [3, 7], Hakuda: [4, 9], Defense: [2, 7], Hoho: [3, 8], Intellect: [2, 7] },
      hpBonus: 20, reiatsuBonus: 20, staminaBonus: 10,
      bonusDesc: 'âš”ï¸ Shinigami: +20 HP, +20 Reiatsu, Hakuda Ã©levÃ©'
    },
    'Hollow': {
      ranges: { Reiatsu: [4, 9], Endurance: [4, 8], Hakuda: [3, 8], Defense: [4, 9], Hoho: [2, 6], Intellect: [1, 5] },
      hpBonus: 30, reiatsuBonus: 30, staminaBonus: 20,
      bonusDesc: 'ğŸ‘¹ Hollow: +30 HP, +30 Reiatsu, DÃ©fense Ã©levÃ©e'
    },
    'Arrancar': {
      ranges: { Reiatsu: [5, 10], Endurance: [4, 9], Hakuda: [4, 9], Defense: [4, 8], Hoho: [4, 9], Intellect: [2, 7] },
      hpBonus: 40, reiatsuBonus: 40, staminaBonus: 20,
      bonusDesc: 'ğŸ˜ˆ Arrancar: +40 HP, +40 Reiatsu, Stats Ã©quilibrÃ©es Ã©levÃ©es'
    },
    'Quincy': {
      ranges: { Reiatsu: [5, 10], Endurance: [2, 6], Hakuda: [1, 5], Defense: [1, 5], Hoho: [3, 8], Intellect: [4, 9] },
      hpBonus: 0, reiatsuBonus: 50, staminaBonus: 0,
      bonusDesc: 'âœï¸ Quincy: +50 Reiatsu, Intellect Ã©levÃ©, Faible en physique'
    },
    'Fullbringer': {
      ranges: { Reiatsu: [3, 8], Endurance: [3, 7], Hakuda: [2, 7], Defense: [2, 6], Hoho: [3, 7], Intellect: [3, 8] },
      hpBonus: 10, reiatsuBonus: 20, staminaBonus: 10,
      bonusDesc: 'âœŠ Fullbringer: Stats Ã©quilibrÃ©es, Polyvalent'
    },
    'Ã‚me': {
      ranges: { Reiatsu: [1, 6], Endurance: [1, 5], Hakuda: [0, 4], Defense: [0, 4], Hoho: [1, 5], Intellect: [2, 7] },
      hpBonus: -10, reiatsuBonus: 10, staminaBonus: 0,
      bonusDesc: 'ğŸ‘» Ã‚me: Stats faibles, Potentiel de croissance'
    },
    'Vizard': {
      ranges: { Reiatsu: [5, 10], Endurance: [4, 8], Hakuda: [4, 9], Defense: [3, 7], Hoho: [4, 9], Intellect: [3, 7] },
      hpBonus: 30, reiatsuBonus: 40, staminaBonus: 15,
      bonusDesc: 'ğŸ­ Vizard: Shinigami + Hollow, TrÃ¨s puissant'
    },
    'Hybrid': {
      ranges: { Reiatsu: [3, 9], Endurance: [3, 8], Hakuda: [3, 8], Defense: [3, 7], Hoho: [3, 8], Intellect: [3, 8] },
      hpBonus: 20, reiatsuBonus: 25, staminaBonus: 15,
      bonusDesc: 'ğŸ”€ Hybride: Stats variÃ©es, Potentiel unique'
    }
  };
  
  speciesArray.forEach(species => {
    const config = raceConfigs[species];
    if (config) {
      Object.keys(baseStats).forEach(stat => {
        const [min, max] = config.ranges[stat];
        const roll = randomRange(min, max);
        baseStats[stat] = Math.max(baseStats[stat], roll);
      });
      
      hpBase += config.hpBonus;
      reiatsuBase += config.reiatsuBonus;
      staminaBase += config.staminaBonus;
      bonuses.push(config.bonusDesc);
    }
  });
  
  if (bonuses.length === 0) {
    Object.keys(baseStats).forEach(stat => {
      baseStats[stat] = randomRange(1, 5);
    });
    bonuses.push('â“ Race inconnue: Stats de base');
  }
  
  return {
    attributes: baseStats,
    maxHp: Math.max(30, hpBase + baseStats.Defense * 5),
    maxReiatsu: Math.max(20, reiatsuBase + baseStats.Reiatsu * 3),
    maxStamina: Math.max(20, staminaBase + baseStats.Endurance * 3),
    bonuses: bonuses
  };
}

function randomRange(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// ===== SUPPRESSION DE CARTE =====

function deleteCard(i) {
  if (confirm("Supprimer cette fiche ?")) {
    // Emit to server via socket to delete player and save to DB
    socket.emit('deletePlayer', i);
    
    // Immediately remove from local state
    currentRP.players.splice(i, 1);
    showPlayers(currentRP);
    updateCharacterSelect();
  }
}

// ===== INVENTAIRE =====

function openInventory(i) {
  currentInvIndex = i;
  const pj = currentRP.players[i];
  
  if (!pj.inventory) pj.inventory = [];
  
  const invTitle = document.getElementById("invTitle");
  if (invTitle) invTitle.innerText = "ğŸ’ Inventaire de " + pj.name;
  
  renderInventory();
  
  const modal = document.getElementById("invModal");
  if (modal) modal.style.display = "flex";
}

function renderInventory() {
  const pj = currentRP.players[currentInvIndex];
  const inv = pj.inventory || [];
  const list = document.getElementById("invList");
  
  if (!list) return;
  
  if (inv.length === 0) {
    list.innerHTML = '<div class="inv-empty">ğŸ“¦ Inventaire vide</div>';
  } else {
    list.innerHTML = inv.map((item, idx) => {
      const itemData = parseItem(item);
      return `
        <div class="inv-item ${itemData.category}">
          <span class="inv-item-name">${itemData.icon} ${itemData.name}</span>
          <span class="inv-item-qty">x${itemData.qty}</span>
          <div class="inv-item-actions">
            <button onclick="changeQty(${idx}, -1)">â–</button>
            <button onclick="changeQty(${idx}, 1)">â•</button>
            <button class="delete-btn" onclick="removeItem(${idx})">ğŸ—‘ï¸</button>
          </div>
        </div>
      `;
    }).join("");
  }
  
  const totalItems = inv.reduce((sum, item) => {
    const q = parseItem(item).qty;
    return sum + q;
  }, 0);
  
  const invCount = document.getElementById("invCount");
  if (invCount) invCount.innerText = `${inv.length} type(s), ${totalItems} objet(s)`;
}

function parseItem(item) {
  if (typeof item === 'object') {
    return {
      name: item.name || item,
      qty: item.qty || 1,
      category: item.category || 'misc',
      icon: getItemIcon(item.category || 'misc')
    };
  }
  
  const parts = item.split('|');
  const name = parts[0] || item;
  const qty = parseInt(parts[1]) || 1;
  const category = parts[2] || guessCategory(name);
  
  return {
    name: name,
    qty: qty,
    category: category,
    icon: getItemIcon(category)
  };
}

function guessCategory(name) {
  const lower = name.toLowerCase();
  if (lower.includes('Ã©pÃ©e') || lower.includes('zanpakuto') || lower.includes('arme') || lower.includes('katana')) return 'weapon';
  if (lower.includes('armure') || lower.includes('protection') || lower.includes('bouclier')) return 'armor';
  if (lower.includes('potion') || lower.includes('pilule') || lower.includes('nourriture') || lower.includes('soin')) return 'consumable';
  if (lower.includes('clÃ©') || lower.includes('badge') || lower.includes('pass')) return 'key';
  return 'misc';
}

function getItemIcon(category) {
  switch (category) {
    case 'weapon': return 'âš”ï¸';
    case 'armor': return 'ğŸ›¡ï¸';
    case 'consumable': return 'ğŸ§ª';
    case 'key': return 'ğŸ”‘';
    default: return 'ğŸ“¦';
  }
}

function addItem() {
  const nameInput = document.getElementById("newItem");
  const qtyInput = document.getElementById("newItemQty");
  
  if (!nameInput) return;
  
  const name = nameInput.value.trim();
  const qty = parseInt(qtyInput?.value) || 1;
  
  if (!name) {
    alert("Entrez un nom d'objet");
    return;
  }
  
  const pj = currentRP.players[currentInvIndex];
  
  const existingIndex = pj.inventory.findIndex(item => {
    const parsed = parseItem(item);
    return parsed.name.toLowerCase() === name.toLowerCase();
  });
  
  if (existingIndex >= 0) {
    const existing = parseItem(pj.inventory[existingIndex]);
    const category = existing.category;
    pj.inventory[existingIndex] = `${existing.name}|${existing.qty + qty}|${category}`;
  } else {
    const category = guessCategory(name);
    pj.inventory.push(`${name}|${qty}|${category}`);
  }
  
  nameInput.value = "";
  if (qtyInput) qtyInput.value = "1";
  renderInventory();
}

function changeQty(idx, delta) {
  const pj = currentRP.players[currentInvIndex];
  const item = parseItem(pj.inventory[idx]);
  
  const newQty = item.qty + delta;
  
  if (newQty <= 0) {
    removeItem(idx);
  } else {
    pj.inventory[idx] = `${item.name}|${newQty}|${item.category}`;
    renderInventory();
  }
}

function removeItem(idx) {
  const pj = currentRP.players[currentInvIndex];
  const item = parseItem(pj.inventory[idx]);
  
  if (confirm(`Supprimer "${item.name}" ?`)) {
    pj.inventory.splice(idx, 1);
    renderInventory();
  }
}

function clearInventory() {
  if (confirm("Vider tout l'inventaire ?")) {
    currentRP.players[currentInvIndex].inventory = [];
    renderInventory();
  }
}

function closeInv() {
  const modal = document.getElementById("invModal");
  if (modal) modal.style.display = "none";
  currentInvIndex = -1;
}

// ===== NPC =====

function openNPC() {
  const list = document.getElementById("npcList");
  if (!list) return;
  
  list.innerHTML = "";
  (currentRP.npcs || []).forEach(n => {
    const d = document.createElement("div");
    d.className = "npcCard";
    d.innerHTML = `<b>${n.name}</b> â€” vu par: ${n.knownBy.join(", ")}<br><i>${n.description || ""}</i>`;
    list.appendChild(d);
  });
  
  const modal = document.getElementById("npcModal");
  if (modal) modal.style.display = "flex";
}

function closeNPC() {
  const modal = document.getElementById("npcModal");
  if (modal) modal.style.display = "none";
}

// ===== BESTIAIRE =====

function openBestiaire() {
  const modal = document.getElementById("bestiaireModal");
  const list = document.getElementById("bestiaireList");
  
  if (!list || !modal) return;
  
  list.innerHTML = "";
  
  const factions = currentRP.bestiaire || {};
  if (Object.keys(factions).length === 0) {
    list.innerHTML = "<i>Aucun personnage dÃ©fini pour ce RP.</i>";
    modal.style.display = "flex";
    return;
  }
  
  Object.entries(factions).forEach(([faction, persos]) => {
    const bloc = document.createElement("div");
    bloc.innerHTML = `<h3 style="margin-top:20px;color:#ffcc66">${faction}</h3>`;
    persos.forEach((p, index) => {
      const known = (p.knownBy && p.knownBy.length > 0);
      const color = known ? "#58a6ff" : "#777";
      const who = known ? `(vu par : ${p.knownBy.join(", ")})` : "(inconnu)";
      const div = document.createElement("div");
      div.style.borderBottom = "1px solid #333";
      div.style.padding = "8px 2px";
      div.innerHTML = `
        <b style="color:${color}">${p.name}</b>
        <button class='btn' style='float:right' onclick='openDetail("${faction}",${index})'>ğŸ” DÃ©tails</button>
        <br><span style="color:#aaa">${p.role || ""}</span><br>
        <span style="color:#aaa;">Localisation :</span> ${p.location || "?"}<br>
        <small>${who}</small>
      `;
      bloc.appendChild(div);
    });
    list.appendChild(bloc);
  });
  
  modal.style.display = "flex";
}

function closeBestiaire() {
  const modal = document.getElementById("bestiaireModal");
  if (modal) modal.style.display = "none";
}

function openDetail(factionName, index) {
  const faction = currentRP.bestiaire[factionName];
  if (!faction) return;
  
  const p = faction[index];
  const detail = document.getElementById("detailContent");
  if (!detail) return;
  
  let statsHTML = "";
  if (p.stats) {
    const values = Object.values(p.stats).filter(v => typeof v === 'number');
    const maxStat = Math.max(...values, 1);
    
    statsHTML = `<div class="stats-grid" style="margin-top:15px;">
      <div class="stats-header">
        <span>Stats</span>
        <span class="max-indicator">Max: ${maxStat}</span>
      </div>
      ${Object.entries(p.stats).map(([k, v]) => {
        if (typeof v !== 'number') return `<div class="stat-item"><span class="stat-name">${k}</span><span>${v}</span></div>`;
        const percent = (v / maxStat) * 100;
        const color = getStatColor(percent);
        return `
        <div class="stat-item">
          <span class="stat-name">${k}</span>
          <div class="stat-bar">
            <div class="stat-fill" style="width:${percent}%; background:${color}"></div>
          </div>
          <span class="stat-value">${v}</span>
        </div>
      `;
      }).join("")}
    </div>`;
  }
  
  detail.innerHTML = `
    <h3 style="color:#58a6ff;margin-top:0;">${p.name}</h3>
    <p><b>EspÃ¨ce :</b> ${p.species || "?"} | <b>Faction :</b> ${factionName}</p>
    ${p.age ? `<p><b>Ã‚ge :</b> ${p.age}</p>` : ""}
    <p><b>RÃ´le :</b> ${p.role || "â€“"}</p>
    <p><b>Localisation actuelle :</b> ${p.location || "Inconnue"}</p>
    ${p.appearance ? `<p><b>Apparence :</b><br>${p.appearance}</p>` : ""}
    ${p.description ? `<p><b>Description :</b><br>${p.description}</p>` : ""}
    ${p.techniques ? `<p><b>Techniques connues :</b><br>${p.techniques.join(", ")}</p>` : ""}
    ${statsHTML}
    ${p.hidden ? `<details><summary>ğŸ”’ Informations cachÃ©es</summary><p>${p.hidden}</p></details>` : ""}
  `;
  
  const modal = document.getElementById("detailModal");
  if (modal) modal.style.display = "flex";
}

function closeDetail() {
  const modal = document.getElementById("detailModal");
  if (modal) modal.style.display = "none";
}

// ===== SYSTÃˆME DE DÃ‰PLACEMENT =====

// ===== SUITE DU CODE CORRIGÃ‰ (PARTIE 5) =====

const LOCATIONS = {
  monde_humain: [
    { id: 'karakura', name: 'Karakura Town', icon: 'ğŸ™ï¸', desc: 'Ville principale' },
    { id: 'karakura_school', name: 'LycÃ©e Karakura', icon: 'ğŸ«', desc: 'Ã‰cole d\'Ichigo' },
    { id: 'urahara_shop', name: 'Urahara Shop', icon: 'ğŸª', desc: 'Magasin mystÃ©rieux' },
    { id: 'karakura_hospital', name: 'HÃ´pital', icon: 'ğŸ¥', desc: 'Clinique Kurosaki' },
    { id: 'karakura_park', name: 'Parc central', icon: 'ğŸŒ³', desc: 'Lieu de rencontre' },
    { id: 'karakura_river', name: 'RiviÃ¨re', icon: 'ğŸŒŠ', desc: 'Berges calmes' },
    { id: 'naruki_city', name: 'Naruki City', icon: 'ğŸŒƒ', desc: 'Ville voisine' }
  ],
  soul_society: [
    { id: 'seireitei', name: 'Seireitei', icon: 'â›©ï¸', desc: 'CitÃ© des Shinigami' },
    { id: 'gotei13_hq', name: 'QG du Gotei 13', icon: 'ğŸ¯', desc: 'Quartier gÃ©nÃ©ral' },
    { id: 'division_1', name: '1Ã¨re Division', icon: '1ï¸âƒ£', desc: 'Commandement' },
    { id: 'division_4', name: '4Ã¨me Division', icon: '4ï¸âƒ£', desc: 'Soins mÃ©dicaux' },
    { id: 'division_11', name: '11Ã¨me Division', icon: 'âš”ï¸', desc: 'Combat' },
    { id: 'division_12', name: '12Ã¨me Division', icon: 'ğŸ”¬', desc: 'Recherche' },
    { id: 'rukongai', name: 'Rukongai', icon: 'ğŸšï¸', desc: 'Districts extÃ©rieurs' },
    { id: 'sokyoku_hill', name: 'Colline SÅkyoku', icon: 'â›°ï¸', desc: 'Lieu d\'exÃ©cution' },
    { id: 'central_46', name: 'Central 46', icon: 'âš–ï¸', desc: 'Tribunal suprÃªme' }
  ],
  hueco_mundo: [
    { id: 'las_noches', name: 'Las Noches', icon: 'ğŸ°', desc: 'Palais d\'Aizen' },
    { id: 'menos_forest', name: 'ForÃªt des Menos', icon: 'ğŸŒ²', desc: 'Territoire Hollow' },
    { id: 'white_desert', name: 'DÃ©sert blanc', icon: 'ğŸœï¸', desc: 'Sables infinis' },
    { id: 'espada_quarters', name: 'Quartiers Espada', icon: 'ğŸ‘‘', desc: 'RÃ©sidence des Espada' },
    { id: 'throne_room', name: 'Salle du trÃ´ne', icon: 'ğŸª‘', desc: 'Centre du pouvoir' }
  ],
  autres: [
    { id: 'dangai', name: 'Dangai', icon: 'ğŸŒ€', desc: 'Passage entre mondes' },
    { id: 'valley_screams', name: 'VallÃ©e des Cris', icon: 'ğŸ‘»', desc: 'Dimension parallÃ¨le' },
    { id: 'royal_palace', name: 'Palais du Roi', icon: 'ğŸ‘‘', desc: 'Dimension royale', locked: true },
    { id: 'wandenreich', name: 'Wandenreich', icon: 'âœï¸', desc: 'Empire Quincy', locked: true },
    { id: 'garganta', name: 'Garganta', icon: 'ğŸ•³ï¸', desc: 'Voie des Hollows' }
  ]
};

function openTravel(i) {
  currentTravelIndex = i;
  const pj = currentRP.players[i];
  
  const travelTitle = document.getElementById("travelTitle");
  const currentLocationDisplay = document.getElementById("currentLocationDisplay");
  
  if (travelTitle) travelTitle.innerText = "ğŸš¶ DÃ©placement de " + pj.name;
  if (currentLocationDisplay) currentLocationDisplay.innerText = pj.location || "Inconnu";
  
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  const firstTab = document.querySelector('.tab-btn');
  if (firstTab) firstTab.classList.add('active');
  
  currentRegion = 'monde_humain';
  renderLocations();
  
  const modal = document.getElementById("travelModal");
  if (modal) modal.style.display = "flex";
}

function closeTravel() {
  const modal = document.getElementById("travelModal");
  if (modal) modal.style.display = "none";
  currentTravelIndex = -1;
}

function showRegion(region) {
  currentRegion = region;
  
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.onclick && btn.onclick.toString().includes(region)) {
      btn.classList.add('active');
    }
  });
  
  renderLocations();
}

function renderLocations() {
  const pj = currentRP.players[currentTravelIndex];
  const currentLoc = pj.location || "";
  const locations = LOCATIONS[currentRegion] || [];
  const list = document.getElementById("locationsList");
  
  if (!list) return;
  
  list.innerHTML = locations.map(loc => {
    const isCurrent = currentLoc.toLowerCase() === loc.name.toLowerCase();
    const isLocked = loc.locked || false;
    
    let classes = "location-card";
    if (isCurrent) classes += " current";
    if (isLocked) classes += " locked";
    
    return `
      <div class="${classes}" onclick="${isLocked ? '' : `travelTo('${loc.name}')`}">
        <span class="loc-icon">${loc.icon}</span>
        <span class="loc-name">${isCurrent ? 'âœ“ ' : ''}${loc.name}</span>
        <span class="loc-desc">${isLocked ? 'ğŸ”’ VerrouillÃ©' : loc.desc}</span>
      </div>
    `;
  }).join("");
}

function travelTo(locationName) {
  const pj = currentRP.players[currentTravelIndex];
  
  if (pj.location === locationName) {
    alert("Vous Ãªtes dÃ©jÃ  Ã  cet endroit !");
    return;
  }
  
  const oldLocation = pj.location || "Inconnu";
  pj.location = locationName;
  
  const locationsList = document.getElementById("locationsList");
  if (locationsList) {
    locationsList.classList.add("traveling");
    setTimeout(() => {
      locationsList.classList.remove("traveling");
    }, 500);
  }
  
  const currentLocationDisplay = document.getElementById("currentLocationDisplay");
  if (currentLocationDisplay) currentLocationDisplay.innerText = locationName;
  
  renderLocations();
  showPlayers(currentRP);
  syncPlayerUpdate(currentTravelIndex);
  
  appendMsg("narrateur", `ğŸ“ ${pj.name} se dÃ©place de "${oldLocation}" vers "${locationName}".`);
}

function addCustomLocation() {
  const name = prompt("Nom du nouveau lieu :");
  if (!name) return;
  
  const region = currentRegion;
  const icon = prompt("IcÃ´ne (emoji) :", "ğŸ“") || "ğŸ“";
  const desc = prompt("Description courte :", "") || "";
  
  LOCATIONS[region].push({
    id: name.toLowerCase().replace(/\s/g, '_'),
    name: name,
    icon: icon,
    desc: desc
  });
  
  renderLocations();
}

// ===== SYSTÃˆME DE TEMPS RP =====

function initRPTime() {
  if (currentRP?.rpTime) {
    rpTime.date = new Date(currentRP.rpTime.date);
    rpTime.tour = currentRP.rpTime.tour || 1;
  } else {
    rpTime.date = new Date(RP_START_DATE);
    rpTime.tour = 1;
  }
  updateTimeDisplay();
}

function updateTimeDisplay() {
  const date = rpTime.date;
  
  const jour = JOURS[date.getDay()];
  const jourNum = String(date.getDate()).padStart(2, '0');
  const mois = MOIS[date.getMonth()];
  const heures = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  
  const rpDate = document.getElementById('rpDate');
  const rpTimeEl = document.getElementById('rpTime');
  
  if (rpDate) rpDate.innerHTML = `ğŸ“… ${jour} ${jourNum} ${mois}`;
  if (rpTimeEl) rpTimeEl.innerHTML = `ğŸ• ${heures}:${minutes}`;
  
  const datetime = document.querySelector('.rp-datetime');
  if (datetime) {
    datetime.classList.remove('day', 'night');
    const hour = date.getHours();
    if (hour >= 6 && hour < 19) {
      datetime.classList.add('day');
    } else {
      datetime.classList.add('night');
    }
  }
  
  const fullDisplay = document.getElementById('timeDisplayFull');
  if (fullDisplay) {
    fullDisplay.innerHTML = `${jour} ${jourNum} ${mois} - ${heures}:${minutes}`;
  }
  
  const tourDisplay = document.getElementById('timeDisplayTour');
  if (tourDisplay) {
    tourDisplay.innerHTML = `Tour ${rpTime.tour}`;
  }
  
  const daysUntil = document.getElementById('daysUntilEvent');
  if (daysUntil) {
    const diff = RUKIA_EVENT_DATE - rpTime.date;
    const daysLeft = Math.ceil(diff / (1000 * 60 * 60 * 24));
    
    if (daysLeft > 0) {
      daysUntil.innerHTML = `â³ ${daysLeft} jour(s) avant la rencontre Rukia/Ichigo`;
    } else if (daysLeft === 0) {
      daysUntil.innerHTML = `ğŸ”´ C'EST AUJOURD'HUI ! La rencontre approche...`;
    } else {
      daysUntil.innerHTML = `âœ… La rencontre Rukia/Ichigo a eu lieu il y a ${Math.abs(daysLeft)} jour(s)`;
    }
  }
  
  if (currentRP) {
    currentRP.rpTime = {
      date: rpTime.date.toISOString(),
      tour: rpTime.tour
    };
  }
}

function openTimeControl() {
  updateTimeDisplay();
  
  const dateInput = document.getElementById('manualDate');
  const timeInput = document.getElementById('manualTime');
  
  if (dateInput) {
    const d = rpTime.date;
    dateInput.value = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}`;
  }
  if (timeInput) {
    const d = rpTime.date;
    timeInput.value = `${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
  }
  
  const modal = document.getElementById('timeModal');
  if (modal) modal.style.display = 'flex';
}

function closeTimeControl() {
  const modal = document.getElementById('timeModal');
  if (modal) modal.style.display = 'none';
}

function advanceTime(hours, minutes) {
  const totalMinutes = hours * 60 + minutes;
  rpTime.date = new Date(rpTime.date.getTime() + totalMinutes * 60 * 1000);
  
  updateTimeDisplay();
  
  let msg = '';
  if (hours > 0 && minutes > 0) {
    msg = `${hours}h${minutes}min`;
  } else if (hours > 0) {
    msg = `${hours} heure(s)`;
  } else {
    msg = `${minutes} minute(s)`;
  }
  
  appendMsg('system', `â© Le temps avance de ${msg}. Il est maintenant ${formatRPTime(rpTime.date)}.`);
  announceTimeOfDay();
}

function advanceDay(days) {
  rpTime.date = new Date(rpTime.date.getTime() + days * 24 * 60 * 60 * 1000);
  
  updateTimeDisplay();
  appendMsg('system', `â© ${days} jour(s) s'Ã©coule(nt). Nous sommes maintenant le ${formatRPDate(rpTime.date)}.`);
  announceTimeOfDay();
}

function setTimeOfDay(hours, minutes) {
  rpTime.date.setHours(hours, minutes, 0, 0);
  
  updateTimeDisplay();
  
  const periods = {
    6: 'ğŸŒ… L\'aube se lÃ¨ve...',
    12: 'â˜€ï¸ Le soleil est au zÃ©nith.',
    18: 'ğŸŒ† Le soir tombe sur la ville.',
    22: 'ğŸŒ™ La nuit enveloppe le monde.'
  };
  
  appendMsg('narrateur', periods[hours] || `Il est maintenant ${formatRPTime(rpTime.date)}.`);
}

function setManualDateTime() {
  const dateInput = document.getElementById('manualDate');
  const timeInput = document.getElementById('manualTime');
  
  if (!dateInput || !dateInput.value) {
    alert('Veuillez entrer une date.');
    return;
  }
  
  const [year, month, day] = dateInput.value.split('-').map(Number);
  const [hours, minutes] = timeInput && timeInput.value ? timeInput.value.split(':').map(Number) : [12, 0];
  
  rpTime.date = new Date(year, month - 1, day, hours, minutes);
  
  updateTimeDisplay();
  appendMsg('system', `ğŸ“… Date modifiÃ©e: ${formatRPDate(rpTime.date)} Ã  ${formatRPTime(rpTime.date)}.`);
  closeTimeControl();
}

function resetRPTime() {
  if (confirm('Revenir au 01 Avril (dÃ©but du RP) ?')) {
    rpTime.date = new Date(RP_START_DATE);
    rpTime.tour = 1;
    
    updateTimeDisplay();
    appendMsg('system', 'ğŸ”„ Temps rÃ©initialisÃ© au 01 Avril, 12:00 (Tour 1).');
    closeTimeControl();
  }
}

function formatRPDate(date) {
  const jour = JOURS[date.getDay()];
  const jourNum = String(date.getDate()).padStart(2, '0');
  const mois = MOIS[date.getMonth()];
  return `${jour} ${jourNum} ${mois}`;
}

function formatRPTime(date) {
  const heures = String(date.getHours()).padStart(2, '0');
  const minutes = String(date.getMinutes()).padStart(2, '0');
  return `${heures}:${minutes}`;
}

function announceTimeOfDay() {
  const hour = rpTime.date.getHours();
  let period = '';
  
  if (hour >= 5 && hour < 8) period = 'ğŸŒ… Le soleil se lÃ¨ve Ã  l\'horizon.';
  else if (hour >= 8 && hour < 12) period = 'â˜€ï¸ La matinÃ©e est bien entamÃ©e.';
  else if (hour >= 12 && hour < 14) period = 'ğŸŒ C\'est l\'heure du dÃ©jeuner.';
  else if (hour >= 14 && hour < 17) period = 'â˜€ï¸ L\'aprÃ¨s-midi suit son cours.';
  else if (hour >= 17 && hour < 20) period = 'ğŸŒ† Le soir approche.';
  else if (hour >= 20 && hour < 23) period = 'ğŸŒ™ La nuit est tombÃ©e.';
  else period = 'ğŸŒ‘ C\'est le milieu de la nuit.';
  
  const isEventDay = rpTime.date.getDate() === 12 && rpTime.date.getMonth() === 4;
  if (isEventDay && hour >= 19) {
    period += '\nâš ï¸ L\'heure de la rencontre fatidique approche...';
  }
}

function advanceTimeOnTurn(minutes = 5) {
  rpTime.date = new Date(rpTime.date.getTime() + minutes * 60 * 1000);
  updateTimeDisplay();
}

function checkSpecialEvents() {
  const date = rpTime.date;
  const day = date.getDate();
  const month = date.getMonth();
  const hour = date.getHours();
  
  if (month === 4 && day === 12 && hour === 19 && date.getMinutes() >= 13) {
    appendMsg('narrateur', 'âš¡ CE SOIR, LE DESTIN S\'ACCOMPLIT ! Rukia Kuchiki rencontre Ichigo Kurosaki pour la premiÃ¨re fois...');
  }
}

function getTimeOfDayPeriod() {
  const hour = rpTime.date.getHours();
  
  if (hour >= 5 && hour < 7) return { name: 'Aube', icon: 'ğŸŒ…', class: 'dawn' };
  if (hour >= 7 && hour < 12) return { name: 'Matin', icon: 'â˜€ï¸', class: 'morning' };
  if (hour >= 12 && hour < 14) return { name: 'Midi', icon: 'ğŸŒ', class: 'noon' };
  if (hour >= 14 && hour < 17) return { name: 'AprÃ¨s-midi', icon: 'ğŸŒ¤ï¸', class: 'afternoon' };
  if (hour >= 17 && hour < 20) return { name: 'Soir', icon: 'ğŸŒ†', class: 'evening' };
  if (hour >= 20 && hour < 23) return { name: 'Nuit', icon: 'ğŸŒ™', class: 'night' };
  return { name: 'Nuit profonde', icon: 'ğŸŒ‘', class: 'midnight' };
}

// ===== DÃ‰TAILS JOUEUR =====

// ===== SUITE DU CODE CORRIGÃ‰ (PARTIE 6 - FINALE) =====

function openPlayerDetails(index) {
  currentDetailIndex = index;
  const pj = currentRP.players[index];
  
  // Initialiser les valeurs manquantes
  if (pj.hp === undefined) pj.hp = 100;
  if (pj.maxHp === undefined) pj.maxHp = 100;
  if (pj.reiatsu === undefined) pj.reiatsu = 50;
  if (pj.maxReiatsu === undefined) pj.maxReiatsu = 50;
  if (pj.stamina === undefined) pj.stamina = 50;
  if (pj.maxStamina === undefined) pj.maxStamina = 50;
  if (!pj.status) pj.status = [];
  if (!pj.stats) {
    pj.stats = { Reiatsu: 5, Endurance: 5, Hakuda: 5, Defense: 5, Hoho: 5, Intellect: 5 };
  }
  
  const hpPercent = (pj.hp / pj.maxHp) * 100;
  const reiatsuPercent = (pj.reiatsu / pj.maxReiatsu) * 100;
  const staminaPercent = (pj.stamina / pj.maxStamina) * 100;
  
  const statDescriptions = {
    Reiatsu: { icon: 'ğŸ”µ', name: 'Pression Spirituelle', desc: 'Puissance des sorts (KidÅ, Cero, Heilig Pfeil)' },
    Endurance: { icon: 'ğŸŸ¡', name: 'Endurance', desc: 'CapacitÃ© Ã  utiliser des attaques physiques' },
    Hakuda: { icon: 'ğŸ‘Š', name: 'Hakuda / Zanjutsu', desc: 'DÃ©gÃ¢ts physiques (mains nues / Ã©pÃ©e)' },
    Defense: { icon: 'ğŸ›¡ï¸', name: 'DÃ©fense', desc: 'RÃ©duction des dÃ©gÃ¢ts reÃ§us' },
    Hoho: { icon: 'ğŸ’¨', name: 'HohÅ / Vitesse', desc: 'Esquive, Shunpo, SonÃ­do, Hirenkyaku' },
    Intellect: { icon: 'ğŸ§ ', name: 'Intellect', desc: 'Coups critiques, StratÃ©gie, Perception' }
  };
  
  const values = Object.values(pj.stats);
  const maxStat = Math.max(...values, 1);
  
  const statsHTML = Object.entries(pj.stats).map(([k, v]) => {
    const info = statDescriptions[k] || { icon: 'â“', name: k, desc: '' };
    const percent = (v / maxStat) * 100;
    const color = getStatColor(percent);
    
    return `
      <div class="stat-detail-item" title="${info.desc}">
        <div class="stat-detail-header">
          <span class="stat-detail-icon">${info.icon}</span>
          <span class="stat-detail-name">${info.name}</span>
          <span class="stat-detail-value">${v}</span>
        </div>
        <div class="stat-bar">
          <div class="stat-fill" style="width:${percent}%; background:${color}"></div>
        </div>
        <div class="stat-detail-desc">${info.desc}</div>
      </div>
    `;
  }).join('');
  
  const statusHTML = pj.status.length > 0
    ? pj.status.map(s => `<span class="status-tag ${getStatusClass(s)}">${getStatusIcon(s)} ${s}</span>`).join('')
    : '<span style="color:#666">Aucun statut</span>';
  
  const invCount = pj.inventory?.length || 0;
  const invTotal = pj.inventory?.reduce((sum, item) => sum + (parseItem(item).qty || 1), 0) || 0;
  
  const combatStats = calculateCombatStats(pj);
  
  const titleEl = document.getElementById('playerDetailTitle');
  if (titleEl) titleEl.innerHTML = `ğŸ“‹ ${pj.name}`;
  
  const contentEl = document.getElementById('playerDetailContent');
  if (contentEl) {
    contentEl.innerHTML = `
      <div class="player-detail-header">
        <div class="player-avatar">${getPlayerAvatar(pj)}</div>
        <div class="player-main-info">
          <h3>${pj.name}</h3>
          <p class="player-subtitle">${pj.species || 'EspÃ¨ce inconnue'} â€¢ ${pj.age || '?'} ans</p>
          <div class="player-level-xp">
            <span class="badge badge-level">â­ Niveau ${pj.level || 1}</span>
            <span class="badge badge-xp">âœ¨ ${pj.xp || 0}/100 XP</span>
          </div>
        </div>
      </div>
      
      ${pj.raceBonuses ? `
      <div class="race-bonuses">
        ${pj.raceBonuses.map(b => `<div class="race-bonus">${b}</div>`).join('')}
      </div>
      ` : ''}
      
      <div class="detail-section-player">
        <h4>ğŸ’ª Ressources</h4>
        
        <div class="resource-detail">
          <div class="resource-detail-header">
            <span>â¤ï¸ Points de Vie (HP)</span>
            <span>${pj.hp} / ${pj.maxHp}</span>
          </div>
          <div class="resource-bar-large hp-bar-bg">
            <div class="resource-fill-large hp-fill-color" style="width:${hpPercent}%"></div>
          </div>
          <div class="resource-actions">
            <button onclick="modifyResource('hp', 10)">+10</button>
            <button onclick="modifyResource('hp', 25)">+25</button>
            <button onclick="modifyResource('hp', 999)">Full</button>
            <button onclick="modifyResource('hp', -10)" class="btn-dmg">-10</button>
            <button onclick="modifyResource('hp', -25)" class="btn-dmg">-25</button>
          </div>
        </div>
        
        <div class="resource-detail">
          <div class="resource-detail-header">
            <span>ğŸ”µ Reiatsu (Mana Spirituel)</span>
            <span>${pj.reiatsu} / ${pj.maxReiatsu}</span>
          </div>
          <div class="resource-bar-large reiatsu-bar-bg">
            <div class="resource-fill-large reiatsu-fill-color" style="width:${reiatsuPercent}%"></div>
          </div>
          <div class="resource-actions">
            <button onclick="modifyResource('reiatsu', 10)">+10</button>
            <button onclick="modifyResource('reiatsu', 25)">+25</button>
            <button onclick="modifyResource('reiatsu', 999)">Full</button>
            <button onclick="modifyResource('reiatsu', -10)" class="btn-dmg">-10</button>
            <button onclick="modifyResource('reiatsu', -25)" class="btn-dmg">-25</button>
          </div>
          <div class="resource-info">UtilisÃ© pour: KidÅ, Cero, Heilig Pfeil, techniques spirituelles</div>
        </div>
        
        <div class="resource-detail">
          <div class="resource-detail-header">
            <span>ğŸŸ¡ Stamina (Endurance)</span>
            <span>${pj.stamina} / ${pj.maxStamina}</span>
          </div>
          <div class="resource-bar-large stamina-bar-bg">
            <div class="resource-fill-large stamina-fill-color" style="width:${staminaPercent}%"></div>
          </div>
          <div class="resource-actions">
            <button onclick="modifyResource('stamina', 10)">+10</button>
            <button onclick="modifyResource('stamina', 25)">+25</button>
            <button onclick="modifyResource('stamina', 999)">Full</button>
            <button onclick="modifyResource('stamina', -10)" class="btn-dmg">-10</button>
            <button onclick="modifyResource('stamina', -25)" class="btn-dmg">-25</button>
          </div>
          <div class="resource-info">UtilisÃ© pour: Attaques physiques, Shunpo, SonÃ­do, dÃ©fense active</div>
        </div>
      </div>
      
      <div class="detail-section-player">
        <h4>âš”ï¸ Stats de Combat</h4>
        <div class="combat-stats-grid">
          <div class="combat-stat">
            <span class="combat-stat-icon">âš”ï¸</span>
            <span class="combat-stat-name">Attaque Physique</span>
            <span class="combat-stat-value">${combatStats.physicalDamage}</span>
          </div>
          <div class="combat-stat">
            <span class="combat-stat-icon">âœ¨</span>
            <span class="combat-stat-name">Attaque Spirituelle</span>
            <span class="combat-stat-value">${combatStats.spiritualDamage}</span>
          </div>
          <div class="combat-stat">
            <span class="combat-stat-icon">ğŸ›¡ï¸</span>
            <span class="combat-stat-name">RÃ©duction DÃ©gÃ¢ts</span>
            <span class="combat-stat-value">${combatStats.damageReduction}%</span>
          </div>
          <div class="combat-stat">
            <span class="combat-stat-icon">ğŸ’¨</span>
            <span class="combat-stat-name">Chance d'Esquive</span>
            <span class="combat-stat-value">${combatStats.dodgeChance}%</span>
          </div>
          <div class="combat-stat">
            <span class="combat-stat-icon">ğŸ¯</span>
            <span class="combat-stat-name">Chance Critique</span>
            <span class="combat-stat-value">${combatStats.critChance}%</span>
          </div>
          <div class="combat-stat">
            <span class="combat-stat-icon">ğŸ’¥</span>
            <span class="combat-stat-name">DÃ©gÃ¢ts Critiques</span>
            <span class="combat-stat-value">x${combatStats.critDamage}</span>
          </div>
        </div>
      </div>
      
      <div class="detail-section-player">
        <h4>ğŸ“Š Attributs</h4>
        <div class="stats-detail-grid">
          ${statsHTML}
        </div>
      </div>
      
      <div class="detail-section-player">
        <h4>ğŸ·ï¸ Statuts actifs</h4>
        <div class="status-tags-detail">
          ${statusHTML}
        </div>
        <div class="status-actions">
          <button onclick="addStatus()">â• Ajouter statut</button>
          <button onclick="clearAllStatus()">ğŸ—‘ï¸ Effacer tout</button>
        </div>
      </div>
      
      <div class="detail-section-player">
        <h4>ğŸ“ Localisation</h4>
        <div class="detail-row">
          <span class="detail-label">Position actuelle</span>
          <span class="detail-value">${pj.location || 'Inconnu'}</span>
        </div>
        <button onclick="openTravel(${index}); closePlayerDetails();" style="margin-top:10px; width:100%;">ğŸš¶ Changer de lieu</button>
      </div>
      
      <div class="detail-section-player">
        <h4>ğŸ“ Informations</h4>
        <div class="detail-row">
          <span class="detail-label">Langues</span>
          <span class="detail-value">${pj.languages || '-'}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">CompÃ©tences</span>
          <span class="detail-value">${pj.skills || '-'}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">PersonnalitÃ©</span>
          <span class="detail-value">${pj.traits || '-'}</span>
        </div>
        <div class="detail-row">
          <span class="detail-label">Objectif</span>
          <span class="detail-value">${pj.goals || '-'}</span>
        </div>
      </div>
      
      ${pj.past ? `
      <div class="detail-section-player">
        <h4>ğŸ“– Background</h4>
        <p style="color:#ccc; line-height:1.5; margin:0;">${pj.past}</p>
      </div>
      ` : ''}
      
      <div class="detail-section-player">
        <h4>ğŸ’ Inventaire</h4>
        <div class="detail-row">
          <span class="detail-label">Objets</span>
          <span class="detail-value">${invCount} type(s), ${invTotal} total</span>
        </div>
        <button onclick="openInventory(${index}); closePlayerDetails();" style="margin-top:10px; width:100%;">ğŸ’ Ouvrir l'inventaire</button>
      </div>
      
      <div class="detail-actions">
        <button class="action-heal" onclick="fullRestore()">ğŸ’š Repos complet</button>
        <button class="action-damage" onclick="customDamage()">ğŸ’” Infliger dÃ©gÃ¢ts</button>
        <button class="action-status" onclick="addStatus()">ğŸ·ï¸ Statut</button>
        <button class="action-edit" onclick="editPlayer()">âœï¸ Modifier</button>
      </div>
    `;
  }
  
  const modal = document.getElementById('playerDetailModal');
  if (modal) modal.style.display = 'flex';
}

function calculateCombatStats(pj) {
  const stats = pj.stats || {};
  
  return {
    physicalDamage: (stats.Hakuda || 0) * 2 + Math.floor((stats.Endurance || 0) / 2),
    spiritualDamage: Math.floor((stats.Reiatsu || 0) * 2.5),
    damageReduction: Math.min(50, (stats.Defense || 0) * 3),
    dodgeChance: Math.min(60, (stats.Hoho || 0) * 4),
    critChance: Math.min(40, (stats.Intellect || 0) * 3),
    critDamage: (1.5 + (stats.Intellect || 0) * 0.05).toFixed(2)
  };
}

function fullRestore() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  pj.hp = pj.maxHp;
  pj.reiatsu = pj.maxReiatsu;
  pj.stamina = pj.maxStamina;
  pj.status = pj.status.filter(s => !['KO', 'FatiguÃ©', 'Ã‰puisÃ©'].includes(s));
  
  appendMsg('narrateur', `ğŸŒ™ ${pj.name} se repose et rÃ©cupÃ¨re toutes ses forces !`);
  appendMsg('system', `ğŸ’š HP: ${pj.hp}/${pj.maxHp} | ğŸ”µ Reiatsu: ${pj.reiatsu}/${pj.maxReiatsu} | ğŸŸ¡ Stamina: ${pj.stamina}/${pj.maxStamina}`);
  
  openPlayerDetails(currentDetailIndex);
  showPlayers(currentRP);
  syncPlayerUpdate(currentDetailIndex);
}

function customDamage() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  const damageType = prompt(
    `Quel type de dÃ©gÃ¢ts infliger Ã  ${pj.name}?\n\n` +
    `1. HP (Points de vie)\n` +
    `2. Reiatsu (Ã‰nergie spirituelle)\n` +
    `3. Stamina (Endurance)\n\n` +
    `Entrez le numÃ©ro:`
  );
  
  if (!damageType) return;
  
  const types = { '1': 'hp', '2': 'reiatsu', '3': 'stamina' };
  const resource = types[damageType];
  
  if (!resource) {
    alert('Type invalide!');
    return;
  }
  
  const amount = prompt(`Combien de dÃ©gÃ¢ts ${resource.toUpperCase()}?`);
  if (!amount) return;
  
  const damage = parseInt(amount);
  if (isNaN(damage) || damage < 0) {
    alert('Valeur invalide!');
    return;
  }
  
  modifyResource(resource, -damage);
}

function addStatus() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  const statusList = [
    { name: 'EmpoisonnÃ©', effect: '-5 HP/tour', icon: 'ğŸ¤¢' },
    { name: 'BrÃ»lÃ©', effect: '-3 HP/tour', icon: 'ğŸ”¥' },
    { name: 'Saignement', effect: '-2 HP/tour', icon: 'ğŸ©¸' },
    { name: 'ParalysÃ©', effect: 'Ne peut pas bouger', icon: 'âš¡' },
    { name: 'GelÃ©', effect: 'Vitesse rÃ©duite', icon: 'â„ï¸' },
    { name: 'FatiguÃ©', effect: '-50% Stamina regen', icon: 'ğŸ˜´' },
    { name: 'Ã‰puisÃ©', effect: 'Stamina bloquÃ©e', icon: 'ğŸ’¤' },
    { name: 'Confus', effect: '30% Ã©chec actions', icon: 'ğŸ˜µâ€ğŸ’«' },
    { name: 'AveuglÃ©', effect: '-50% prÃ©cision', icon: 'ğŸ™ˆ' },
    { name: 'DrainÃ©', effect: '-5 Reiatsu/tour', icon: 'ğŸ’«' },
    { name: 'Bouclier', effect: '+20% DÃ©fense', icon: 'ğŸ›¡ï¸' },
    { name: 'RenforcÃ©', effect: '+20% Attaque', icon: 'ğŸ’ª' },
    { name: 'HÃ¢te', effect: '+30% Vitesse', icon: 'âš¡' },
    { name: 'RÃ©gÃ©nÃ©ration', effect: '+5 HP/tour', icon: 'ğŸ’š' },
    { name: 'Concentration', effect: '+20% Critique', icon: 'ğŸ¯' },
    { name: 'Invisible', effect: 'IndÃ©tectable', icon: 'ğŸ‘»' }
  ];
  
  const choice = prompt(
    `Ajouter un statut Ã  ${pj.name}:\n\n` +
    statusList.map((s, i) => `${i + 1}. ${s.icon} ${s.name} (${s.effect})`).join('\n') +
    `\n\n0. PersonnalisÃ©...\n\nEntrez le numÃ©ro:`
  );
  
  if (choice === null) return;
  
  let status;
  const num = parseInt(choice);
  
  if (num === 0) {
    status = prompt('Entrez le nom du statut personnalisÃ©:');
    if (!status) return;
  } else if (num >= 1 && num <= statusList.length) {
    status = statusList[num - 1].name;
  } else {
    alert('Choix invalide!');
    return;
  }
  
  if (!pj.status.includes(status)) {
    pj.status.push(status);
    const statusInfo = statusList.find(s => s.name === status);
    appendMsg('system', `ğŸ·ï¸ ${pj.name} obtient: ${getStatusIcon(status)} ${status}${statusInfo ? ` (${statusInfo.effect})` : ''}`);
  } else {
    alert(`${pj.name} a dÃ©jÃ  ce statut!`);
    return;
  }
  
  openPlayerDetails(currentDetailIndex);
  showPlayers(currentRP);
  syncPlayerUpdate(currentDetailIndex);
}

function clearAllStatus() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  if (pj.status.length === 0) {
    alert(`${pj.name} n'a aucun statut.`);
    return;
  }
  
  if (confirm(`Effacer tous les statuts de ${pj.name}?\n\nStatuts actuels: ${pj.status.join(', ')}`)) {
    pj.status = [];
    appendMsg('system', `âœ¨ Tous les statuts de ${pj.name} ont Ã©tÃ© effacÃ©s.`);
    openPlayerDetails(currentDetailIndex);
    showPlayers(currentRP);
    syncPlayerUpdate(currentDetailIndex);
  }
}

function getPlayerAvatar(pj) {
  const species = (pj.species || '').toLowerCase();
  if (species.includes('arrancar')) return 'ğŸ˜ˆ';
  if (species.includes('hollow')) return 'ğŸ‘¹';
  if (species.includes('vizard')) return 'ğŸ­';
  if (species.includes('shinigami')) return 'âš”ï¸';
  if (species.includes('quincy')) return 'âœï¸';
  if (species.includes('fullbringer')) return 'âœŠ';
  if (species.includes('humain')) return 'ğŸ‘¤';
  if (species.includes('Ã¢me')) return 'ğŸ‘»';
  if (species.includes('hybrid')) return 'ğŸ”€';
  return 'ğŸ­';
}

// ===== SUITE DU CODE CORRIGÃ‰ (PARTIE 7 - FINALE) =====

function editPlayer() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  const choice = prompt(
    `Que voulez-vous modifier pour ${pj.name}?\n\n` +
    `1. Nom\n` +
    `2. Ã‚ge\n` +
    `3. CompÃ©tences\n` +
    `4. PersonnalitÃ©\n` +
    `5. Objectif\n` +
    `6. HP Maximum\n` +
    `7. Reiatsu Maximum\n` +
    `8. Stamina Maximum\n` +
    `9. Modifier une stat\n` +
    `10. Background\n\n` +
    `Entrez le numÃ©ro:`
  );
  
  if (!choice) return;
  
  switch (choice) {
    case '1':
      const newName = prompt('Nouveau nom:', pj.name);
      if (newName && newName.trim()) {
        const oldName = pj.name;
        pj.name = newName.trim();
        appendMsg('system', `âœï¸ ${oldName} renommÃ© en ${pj.name}`);
      }
      break;
      
    case '2':
      const newAge = prompt('Nouvel Ã¢ge:', pj.age);
      if (newAge) {
        pj.age = newAge;
        appendMsg('system', `âœï¸ Ã‚ge de ${pj.name} modifiÃ©: ${pj.age}`);
      }
      break;
      
    case '3':
      const newSkills = prompt('CompÃ©tences:', pj.skills);
      if (newSkills !== null) {
        pj.skills = newSkills;
        appendMsg('system', `âœï¸ CompÃ©tences de ${pj.name} modifiÃ©es`);
      }
      break;
      
    case '4':
      const newTraits = prompt('PersonnalitÃ©:', pj.traits);
      if (newTraits !== null) {
        pj.traits = newTraits;
        appendMsg('system', `âœï¸ PersonnalitÃ© de ${pj.name} modifiÃ©e`);
      }
      break;
      
    case '5':
      const newGoals = prompt('Objectif:', pj.goals);
      if (newGoals !== null) {
        pj.goals = newGoals;
        appendMsg('system', `âœï¸ Objectif de ${pj.name} modifiÃ©`);
      }
      break;
      
    case '6':
      const newMaxHp = prompt('HP Maximum:', pj.maxHp);
      if (newMaxHp && !isNaN(parseInt(newMaxHp))) {
        pj.maxHp = parseInt(newMaxHp);
        pj.hp = Math.min(pj.hp, pj.maxHp);
        appendMsg('system', `âœï¸ HP Max de ${pj.name}: ${pj.maxHp}`);
      }
      break;
      
    case '7':
      const newMaxReiatsu = prompt('Reiatsu Maximum:', pj.maxReiatsu);
      if (newMaxReiatsu && !isNaN(parseInt(newMaxReiatsu))) {
        pj.maxReiatsu = parseInt(newMaxReiatsu);
        pj.reiatsu = Math.min(pj.reiatsu, pj.maxReiatsu);
        appendMsg('system', `âœï¸ Reiatsu Max de ${pj.name}: ${pj.maxReiatsu}`);
      }
      break;
      
    case '8':
      const newMaxStamina = prompt('Stamina Maximum:', pj.maxStamina);
      if (newMaxStamina && !isNaN(parseInt(newMaxStamina))) {
        pj.maxStamina = parseInt(newMaxStamina);
        pj.stamina = Math.min(pj.stamina, pj.maxStamina);
        appendMsg('system', `âœï¸ Stamina Max de ${pj.name}: ${pj.maxStamina}`);
      }
      break;
      
    case '9':
      editStat();
      return; // editStat gÃ¨re dÃ©jÃ  la mise Ã  jour
      
    case '10':
      const newPast = prompt('Background / PassÃ©:', pj.past);
      if (newPast !== null) {
        pj.past = newPast;
        appendMsg('system', `âœï¸ Background de ${pj.name} modifiÃ©`);
      }
      break;
      
    default:
      alert('Choix invalide!');
      return;
  }
  
  openPlayerDetails(currentDetailIndex);
  showPlayers(currentRP);
  syncPlayerUpdate(currentDetailIndex);
}

function editStat() {
  if (currentDetailIndex < 0) return;
  const pj = currentRP.players[currentDetailIndex];
  
  const statDescriptions = {
    Reiatsu: 'ğŸ”µ Pression Spirituelle',
    Endurance: 'ğŸŸ¡ Endurance',
    Hakuda: 'ğŸ‘Š Hakuda / Zanjutsu',
    Defense: 'ğŸ›¡ï¸ DÃ©fense',
    Hoho: 'ğŸ’¨ HohÅ / Vitesse',
    Intellect: 'ğŸ§  Intellect'
  };
  
  const statKeys = Object.keys(pj.stats);
  
  const choice = prompt(
    `Quelle stat modifier pour ${pj.name}?\n\n` +
    statKeys.map((k, i) => `${i + 1}. ${statDescriptions[k] || k}: ${pj.stats[k]}`).join('\n') +
    `\n\nEntrez le numÃ©ro:`
  );
  
  if (!choice) return;
  
  const index = parseInt(choice) - 1;
  if (isNaN(index) || index < 0 || index >= statKeys.length) {
    alert('Choix invalide!');
    return;
  }
  
  const statKey = statKeys[index];
  const newValue = prompt(`Nouvelle valeur pour ${statDescriptions[statKey] || statKey}:`, pj.stats[statKey]);
  
  if (newValue && !isNaN(parseInt(newValue))) {
    const oldValue = pj.stats[statKey];
    pj.stats[statKey] = Math.max(0, Math.min(20, parseInt(newValue)));
    appendMsg('system', `âœï¸ ${pj.name}: ${statDescriptions[statKey] || statKey} ${oldValue} â†’ ${pj.stats[statKey]}`);
    
    openPlayerDetails(currentDetailIndex);
    showPlayers(currentRP);
    syncPlayerUpdate(currentDetailIndex);
  }
}

function closePlayerDetails() {
  const modal = document.getElementById('playerDetailModal');
  if (modal) modal.style.display = 'none';
  currentDetailIndex = -1;
}

// ===== MAP DATA =====

const MAP_DATA = {
  monde_humain: [
    {
      id: 'karakura',
      name: 'Karakura Town',
      icon: 'ğŸ™ï¸',
      desc: 'Ville principale oÃ¹ rÃ©side Ichigo',
      weather: { type: 'sunny', name: 'EnsoleillÃ©', temp: '22Â°C', desc: 'Ciel dÃ©gagÃ©, lÃ©gÃ¨re brise' },
      shops: [
        { name: 'Urahara Shop', icon: 'ğŸª', status: 'open', owner: 'Kisuke Urahara', items: ['Gigai', 'Soul Candy', 'Objets spirituels'] },
        { name: 'Konbini 24h', icon: 'ğŸ¬', status: 'open', owner: 'Vendeur', items: ['Nourriture', 'Boissons', 'Magazines'] }
      ],
      npcs: [
        { name: 'Kisuke Urahara', role: 'Marchand / Ex-Capitaine', icon: 'ğŸ©', attitude: 'friendly' },
        { name: 'Tessai Tsukabishi', role: 'Assistant', icon: 'ğŸ‘¨', attitude: 'friendly' }
      ],
      events: [{ name: 'Hollow Alert', icon: 'ğŸ‘»', desc: 'Des Hollows apparaissent parfois la nuit' }]
    }
  ],
  soul_society: [
    {
      id: 'seireitei',
      name: 'Seireitei',
      icon: 'â›©ï¸',
      desc: 'CitÃ© fortifiÃ©e des Shinigami',
      weather: { type: 'clear', name: 'Clair', temp: '18Â°C', desc: 'Air pur et spirituel' },
      shops: [{ name: 'Armurerie du Gotei', icon: 'âš”ï¸', status: 'open', owner: 'Intendance', items: ['ZanpakutÅ standards', 'Uniformes'] }],
      npcs: [{ name: 'Gardes Shinigami', role: 'Patrouille', icon: 'ğŸ’‚', attitude: 'neutral' }],
      events: [{ name: 'Patrouilles actives', icon: 'ğŸš¨', desc: 'SÃ©curitÃ© renforcÃ©e' }]
    }
  ],
  hueco_mundo: [
    {
      id: 'las_noches',
      name: 'Las Noches',
      icon: 'ğŸ°',
      desc: 'Palais d\'Aizen au Hueco Mundo',
      weather: { type: 'night', name: 'Nuit Ã©ternelle', temp: '???', desc: 'Ciel toujours noir' },
      shops: [],
      npcs: [{ name: 'SÅsuke Aizen', role: 'Seigneur', icon: 'ğŸ‘‘', attitude: 'hostile' }],
      events: [{ name: 'Surveillance constante', icon: 'ğŸ‘ï¸', desc: 'Les Espada patrouillent' }]
    }
  ],
  autres: [
    {
      id: 'dangai',
      name: 'Dangai',
      icon: 'ğŸŒ€',
      desc: 'Passage entre les mondes',
      weather: { type: 'void', name: 'NÃ©ant', temp: '???', desc: 'Espace-temps instable' },
      shops: [],
      npcs: [{ name: 'KÅtotsu', role: 'Nettoyeur', icon: 'ğŸš‚', attitude: 'hostile' }],
      events: [{ name: 'Temps instable', icon: 'â°', desc: 'Le temps s\'Ã©coule diffÃ©remment' }]
    }
  ]
};

// ===== FONCTIONS MAP =====

function openMap() {
  currentMapRegion = 'monde_humain';
  selectedLocation = null;
  
  document.querySelectorAll('.region-btn').forEach(btn => btn.classList.remove('active'));
  const firstBtn = document.querySelector('.region-btn');
  if (firstBtn) firstBtn.classList.add('active');
  
  renderMapLocations();
  renderLocationDetails(null);
  
  const modal = document.getElementById("mapModal");
  if (modal) modal.style.display = "flex";
}

function closeMap() {
  const modal = document.getElementById("mapModal");
  if (modal) modal.style.display = "none";
}

function selectMapRegion(region) {
  currentMapRegion = region;
  selectedLocation = null;
  
  document.querySelectorAll('.region-btn').forEach(btn => {
    btn.classList.remove('active');
    if (btn.onclick && btn.onclick.toString().includes(region)) {
      btn.classList.add('active');
    }
  });
  
  renderMapLocations();
  renderLocationDetails(null);
}

function renderMapLocations() {
  const locations = MAP_DATA[currentMapRegion] || [];
  const container = document.getElementById("mapLocations");
  
  if (!container) return;
  
  container.innerHTML = locations.map(loc => {
    const playersHere = currentRP?.players?.filter(p => 
      p.location?.toLowerCase() === loc.name.toLowerCase()
    ) || [];
    
    const isSelected = selectedLocation?.id === loc.id;
    const isLocked = loc.locked || false;
    
    let classes = "map-location";
    if (isSelected) classes += " selected";
    if (isLocked) classes += " locked";
    
    return `
      <div class="${classes}" onclick="${isLocked ? '' : `selectMapLocation('${loc.id}')`}">
        <span class="loc-icon">${loc.icon}</span>
        <span class="loc-name">${loc.name}</span>
        ${playersHere.length > 0 ? `<div class="loc-players">ğŸ‘¥ ${playersHere.length} joueur(s)</div>` : ''}
        ${isLocked ? '<div class="loc-players">ğŸ”’ VerrouillÃ©</div>' : ''}
      </div>
    `;
  }).join("");
}

function selectMapLocation(locId) {
  const locations = MAP_DATA[currentMapRegion] || [];
  selectedLocation = locations.find(l => l.id === locId);
  
  renderMapLocations();
  renderLocationDetails(selectedLocation);
}

function renderLocationDetails(location) {
  const container = document.getElementById("locationDetails");
  
  if (!container) return;
  
  if (!location) {
    container.innerHTML = `
      <div class="location-placeholder">
        <span>ğŸ‘†</span>
        <p>SÃ©lectionnez un lieu pour voir les dÃ©tails</p>
      </div>
    `;
    return;
  }
  
  const playersHere = currentRP?.players?.filter(p => 
    p.location?.toLowerCase() === location.name.toLowerCase()
  ) || [];
  
  container.innerHTML = `
    <div class="location-header">
      <span class="header-icon">${location.icon}</span>
      <div class="header-info">
        <h3>${location.name}</h3>
        <p>${location.desc}</p>
      </div>
    </div>
    
    ${location.weather ? `
    <div class="weather-box">
      <span class="weather-icon">${getWeatherIcon(location.weather.type)}</span>
      <div class="weather-info">
        <div class="weather-name">${location.weather.name}</div>
        <div class="weather-desc">${location.weather.desc}</div>
        <div class="weather-temp">ğŸŒ¡ï¸ ${location.weather.temp}</div>
      </div>
    </div>
    ` : ''}
    
    <div class="detail-section">
      <h4>ğŸ‘¥ Joueurs prÃ©sents</h4>
      ${playersHere.length > 0 ? `
        <div class="players-list">
          ${playersHere.map(p => `
            <div class="player-tag">
              <span>${p.name}</span>
              <span class="player-level">Niv.${p.level || 1}</span>
            </div>
          `).join("")}
        </div>
      ` : '<div class="empty-section">Aucun joueur ici</div>'}
    </div>
    
    <div class="detail-section">
      <h4>ğŸ­ PNJ prÃ©sents</h4>
      ${location.npcs?.length > 0 ? `
        <div class="npc-list">
          ${location.npcs.map(npc => `
            <div class="npc-card">
              <span class="npc-icon">${npc.icon || 'ğŸ‘¤'}</span>
              <div class="npc-info">
                <div class="npc-name">${npc.name}</div>
                <div class="npc-role">${npc.role || ''}</div>
              </div>
              <span class="npc-attitude ${npc.attitude || 'unknown'}">${getAttitudeLabel(npc.attitude)}</span>
            </div>
          `).join("")}
        </div>
      ` : '<div class="empty-section">Aucun PNJ visible</div>'}
    </div>
    
    <div style="margin-top: 20px; text-align: center;">
      <button class="confirm" onclick="quickTravelTo('${location.name}')" style="max-width: 300px;">
        ğŸš¶ Voyager ici
      </button>
    </div>
  `;
}

function getWeatherIcon(type) {
  const icons = {
    sunny: 'â˜€ï¸', cloudy: 'â˜ï¸', rainy: 'ğŸŒ§ï¸', stormy: 'â›ˆï¸',
    snowy: 'â„ï¸', foggy: 'ğŸŒ«ï¸', night: 'ğŸŒ™', clear: 'âœ¨',
    dark: 'ğŸŒ‘', void: 'ğŸŒ€', divine: 'ğŸ’«'
  };
  return icons[type] || 'ğŸŒ¤ï¸';
}

function getAttitudeLabel(attitude) {
  switch (attitude) {
    case 'friendly': return 'ğŸ˜Š Amical';
    case 'neutral': return 'ğŸ˜ Neutre';
    case 'hostile': return 'ğŸ˜  Hostile';
    default: return 'â“ Inconnu';
  }
}

function quickTravelTo(locationName) {
  if (!currentRP || !currentRP.players || currentRP.players.length === 0) {
    alert("Aucun joueur disponible!");
    return;
  }
  
  const playerNames = currentRP.players.map((p, i) => `${i + 1}. ${p.name} (${p.location || 'Inconnu'})`).join('\n');
  const choice = prompt(`Quel joueur dÃ©placer vers "${locationName}"?\n\n${playerNames}\n\nNumÃ©ro:`);
  
  if (!choice) return;
  
  const index = parseInt(choice) - 1;
  if (isNaN(index) || index < 0 || index >= currentRP.players.length) {
    alert("NumÃ©ro invalide!");
    return;
  }
  
  const player = currentRP.players[index];
  const oldLocation = player.location || "Inconnu";
  
  if (oldLocation.toLowerCase() === locationName.toLowerCase()) {
    alert(`${player.name} est dÃ©jÃ  Ã  ${locationName}!`);
    return;
  }
  
  player.location = locationName;
  
  renderMapLocations();
  renderLocationDetails(selectedLocation);
  showPlayers(currentRP);
  syncPlayerUpdate(index);
  
  appendMsg("narrateur", `ğŸ“ ${player.name} se dÃ©place de "${oldLocation}" vers "${locationName}".`);
  alert(`âœ… ${player.name} est maintenant Ã  ${locationName}!`);
}

// ===== SAUVEGARDE =====

async function saveData() {
  try {
    const res = await fetch("/save", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(allData)
    });
    const r = await res.json();
    if (r.ok) {
      alert("âœ… SauvegardÃ© !");
    } else {
      alert("âŒ Erreur : " + r.error);
    }
  } catch (e) {
    alert("âŒ Erreur : " + e.message);
  }
}

// ===== FIN DU SCRIPT =====
</script>
</body>
</html>
